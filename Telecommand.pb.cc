// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Telecommand.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Telecommand.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace lunabotics {
namespace proto {

namespace {

const ::google::protobuf::Descriptor* Telecommand_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Telecommand_reflection_ = NULL;
const ::google::protobuf::Descriptor* Telecommand_Teleoperation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Telecommand_Teleoperation_reflection_ = NULL;
const ::google::protobuf::Descriptor* Telecommand_Autonomy_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Telecommand_Autonomy_reflection_ = NULL;
const ::google::protobuf::Descriptor* Telecommand_SteeringMode_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Telecommand_SteeringMode_reflection_ = NULL;
const ::google::protobuf::Descriptor* Telecommand_SteeringMode_AckermannSteeringData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Telecommand_SteeringMode_AckermannSteeringData_reflection_ = NULL;
const ::google::protobuf::Descriptor* Telecommand_SteeringMode_TurnInSpotSteeringData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Telecommand_SteeringMode_TurnInSpotSteeringData_reflection_ = NULL;
const ::google::protobuf::Descriptor* Telecommand_SteeringMode_CrabSteeringData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Telecommand_SteeringMode_CrabSteeringData_reflection_ = NULL;
const ::google::protobuf::Descriptor* Telecommand_DefineRoute_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Telecommand_DefineRoute_reflection_ = NULL;
const ::google::protobuf::Descriptor* Telecommand_RequestMap_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Telecommand_RequestMap_reflection_ = NULL;
const ::google::protobuf::Descriptor* Telecommand_AdjustPID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Telecommand_AdjustPID_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Telecommand_Type_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_Telecommand_2eproto() {
  protobuf_AddDesc_Telecommand_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "Telecommand.proto");
  GOOGLE_CHECK(file != NULL);
  Telecommand_descriptor_ = file->message_type(0);
  static const int Telecommand_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, teleoperation_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, autonomy_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, steering_mode_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, define_route_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, request_map_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, adjust_pid_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, all_wheel_control_data_),
  };
  Telecommand_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Telecommand_descriptor_,
      Telecommand::default_instance_,
      Telecommand_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Telecommand));
  Telecommand_Teleoperation_descriptor_ = Telecommand_descriptor_->nested_type(0);
  static const int Telecommand_Teleoperation_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_Teleoperation, forward_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_Teleoperation, backward_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_Teleoperation, left_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_Teleoperation, right_),
  };
  Telecommand_Teleoperation_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Telecommand_Teleoperation_descriptor_,
      Telecommand_Teleoperation::default_instance_,
      Telecommand_Teleoperation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_Teleoperation, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_Teleoperation, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Telecommand_Teleoperation));
  Telecommand_Autonomy_descriptor_ = Telecommand_descriptor_->nested_type(1);
  static const int Telecommand_Autonomy_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_Autonomy, enabled_),
  };
  Telecommand_Autonomy_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Telecommand_Autonomy_descriptor_,
      Telecommand_Autonomy::default_instance_,
      Telecommand_Autonomy_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_Autonomy, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_Autonomy, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Telecommand_Autonomy));
  Telecommand_SteeringMode_descriptor_ = Telecommand_descriptor_->nested_type(2);
  static const int Telecommand_SteeringMode_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode, ackermann_steering_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode, turn_in_spot_steering_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode, crab_steering_data_),
  };
  Telecommand_SteeringMode_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Telecommand_SteeringMode_descriptor_,
      Telecommand_SteeringMode::default_instance_,
      Telecommand_SteeringMode_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Telecommand_SteeringMode));
  Telecommand_SteeringMode_AckermannSteeringData_descriptor_ = Telecommand_SteeringMode_descriptor_->nested_type(0);
  static const int Telecommand_SteeringMode_AckermannSteeringData_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode_AckermannSteeringData, max_linear_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode_AckermannSteeringData, bezier_curve_segments_),
  };
  Telecommand_SteeringMode_AckermannSteeringData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Telecommand_SteeringMode_AckermannSteeringData_descriptor_,
      Telecommand_SteeringMode_AckermannSteeringData::default_instance_,
      Telecommand_SteeringMode_AckermannSteeringData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode_AckermannSteeringData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode_AckermannSteeringData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Telecommand_SteeringMode_AckermannSteeringData));
  Telecommand_SteeringMode_TurnInSpotSteeringData_descriptor_ = Telecommand_SteeringMode_descriptor_->nested_type(1);
  static const int Telecommand_SteeringMode_TurnInSpotSteeringData_offsets_[1] = {
  };
  Telecommand_SteeringMode_TurnInSpotSteeringData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Telecommand_SteeringMode_TurnInSpotSteeringData_descriptor_,
      Telecommand_SteeringMode_TurnInSpotSteeringData::default_instance_,
      Telecommand_SteeringMode_TurnInSpotSteeringData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode_TurnInSpotSteeringData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode_TurnInSpotSteeringData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Telecommand_SteeringMode_TurnInSpotSteeringData));
  Telecommand_SteeringMode_CrabSteeringData_descriptor_ = Telecommand_SteeringMode_descriptor_->nested_type(2);
  static const int Telecommand_SteeringMode_CrabSteeringData_offsets_[1] = {
  };
  Telecommand_SteeringMode_CrabSteeringData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Telecommand_SteeringMode_CrabSteeringData_descriptor_,
      Telecommand_SteeringMode_CrabSteeringData::default_instance_,
      Telecommand_SteeringMode_CrabSteeringData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode_CrabSteeringData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode_CrabSteeringData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Telecommand_SteeringMode_CrabSteeringData));
  Telecommand_DefineRoute_descriptor_ = Telecommand_descriptor_->nested_type(3);
  static const int Telecommand_DefineRoute_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_DefineRoute, goal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_DefineRoute, heading_accuracy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_DefineRoute, position_accuracy_),
  };
  Telecommand_DefineRoute_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Telecommand_DefineRoute_descriptor_,
      Telecommand_DefineRoute::default_instance_,
      Telecommand_DefineRoute_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_DefineRoute, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_DefineRoute, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Telecommand_DefineRoute));
  Telecommand_RequestMap_descriptor_ = Telecommand_descriptor_->nested_type(4);
  static const int Telecommand_RequestMap_offsets_[1] = {
  };
  Telecommand_RequestMap_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Telecommand_RequestMap_descriptor_,
      Telecommand_RequestMap::default_instance_,
      Telecommand_RequestMap_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_RequestMap, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_RequestMap, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Telecommand_RequestMap));
  Telecommand_AdjustPID_descriptor_ = Telecommand_descriptor_->nested_type(5);
  static const int Telecommand_AdjustPID_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_AdjustPID, p_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_AdjustPID, i_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_AdjustPID, d_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_AdjustPID, velocity_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_AdjustPID, velocity_multiplier_),
  };
  Telecommand_AdjustPID_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Telecommand_AdjustPID_descriptor_,
      Telecommand_AdjustPID::default_instance_,
      Telecommand_AdjustPID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_AdjustPID, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_AdjustPID, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Telecommand_AdjustPID));
  Telecommand_Type_descriptor_ = Telecommand_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_Telecommand_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Telecommand_descriptor_, &Telecommand::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Telecommand_Teleoperation_descriptor_, &Telecommand_Teleoperation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Telecommand_Autonomy_descriptor_, &Telecommand_Autonomy::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Telecommand_SteeringMode_descriptor_, &Telecommand_SteeringMode::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Telecommand_SteeringMode_AckermannSteeringData_descriptor_, &Telecommand_SteeringMode_AckermannSteeringData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Telecommand_SteeringMode_TurnInSpotSteeringData_descriptor_, &Telecommand_SteeringMode_TurnInSpotSteeringData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Telecommand_SteeringMode_CrabSteeringData_descriptor_, &Telecommand_SteeringMode_CrabSteeringData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Telecommand_DefineRoute_descriptor_, &Telecommand_DefineRoute::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Telecommand_RequestMap_descriptor_, &Telecommand_RequestMap::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Telecommand_AdjustPID_descriptor_, &Telecommand_AdjustPID::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_Telecommand_2eproto() {
  delete Telecommand::default_instance_;
  delete Telecommand_reflection_;
  delete Telecommand_Teleoperation::default_instance_;
  delete Telecommand_Teleoperation_reflection_;
  delete Telecommand_Autonomy::default_instance_;
  delete Telecommand_Autonomy_reflection_;
  delete Telecommand_SteeringMode::default_instance_;
  delete Telecommand_SteeringMode_reflection_;
  delete Telecommand_SteeringMode_AckermannSteeringData::default_instance_;
  delete Telecommand_SteeringMode_AckermannSteeringData_reflection_;
  delete Telecommand_SteeringMode_TurnInSpotSteeringData::default_instance_;
  delete Telecommand_SteeringMode_TurnInSpotSteeringData_reflection_;
  delete Telecommand_SteeringMode_CrabSteeringData::default_instance_;
  delete Telecommand_SteeringMode_CrabSteeringData_reflection_;
  delete Telecommand_DefineRoute::default_instance_;
  delete Telecommand_DefineRoute_reflection_;
  delete Telecommand_RequestMap::default_instance_;
  delete Telecommand_RequestMap_reflection_;
  delete Telecommand_AdjustPID::default_instance_;
  delete Telecommand_AdjustPID_reflection_;
}

void protobuf_AddDesc_Telecommand_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::lunabotics::proto::protobuf_AddDesc_SteeringModeType_2eproto();
  ::lunabotics::proto::protobuf_AddDesc_Point_2eproto();
  ::lunabotics::proto::protobuf_AddDesc_AllWheelControl_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\021Telecommand.proto\022\020lunabotics.proto\032\026S"
    "teeringModeType.proto\032\013Point.proto\032\025AllW"
    "heelControl.proto\"\355\013\n\013Telecommand\0220\n\004typ"
    "e\030\001 \002(\0162\".lunabotics.proto.Telecommand.T"
    "ype\022G\n\022teleoperation_data\030\002 \001(\0132+.lunabo"
    "tics.proto.Telecommand.Teleoperation\022=\n\r"
    "autonomy_data\030\003 \001(\0132&.lunabotics.proto.T"
    "elecommand.Autonomy\022F\n\022steering_mode_dat"
    "a\030\004 \001(\0132*.lunabotics.proto.Telecommand.S"
    "teeringMode\022D\n\021define_route_data\030\005 \001(\0132)"
    ".lunabotics.proto.Telecommand.DefineRout"
    "e\022B\n\020request_map_data\030\006 \001(\0132(.lunabotics"
    ".proto.Telecommand.RequestMap\022@\n\017adjust_"
    "pid_data\030\007 \001(\0132\'.lunabotics.proto.Teleco"
    "mmand.AdjustPID\022A\n\026all_wheel_control_dat"
    "a\030\010 \001(\0132!.lunabotics.proto.AllWheelContr"
    "ol\032O\n\rTeleoperation\022\017\n\007forward\030\001 \002(\010\022\020\n\010"
    "backward\030\002 \002(\010\022\014\n\004left\030\003 \002(\010\022\r\n\005right\030\004 "
    "\002(\010\032\033\n\010Autonomy\022\017\n\007enabled\030\001 \002(\010\032\360\003\n\014Ste"
    "eringMode\0220\n\004type\030\001 \002(\0162\".lunabotics.pro"
    "to.SteeringModeType\022a\n\027ackermann_steerin"
    "g_data\030\002 \001(\0132@.lunabotics.proto.Telecomm"
    "and.SteeringMode.AckermannSteeringData\022e"
    "\n\032turn_in_spot_steering_data\030\003 \001(\0132A.lun"
    "abotics.proto.Telecommand.SteeringMode.T"
    "urnInSpotSteeringData\022W\n\022crab_steering_d"
    "ata\030\004 \001(\0132;.lunabotics.proto.Telecommand"
    ".SteeringMode.CrabSteeringData\032]\n\025Ackerm"
    "annSteeringData\022!\n\023max_linear_velocity\030\001"
    " \001(\002:\0040.33\022!\n\025bezier_curve_segments\030\002 \001("
    "\005:\00220\032\030\n\026TurnInSpotSteeringData\032\022\n\020CrabS"
    "teeringData\032s\n\013DefineRoute\022%\n\004goal\030\001 \002(\013"
    "2\027.lunabotics.proto.Point\022\035\n\020heading_acc"
    "uracy\030\002 \001(\002:\0030.4\022\036\n\021position_accuracy\030\003 "
    "\001(\002:\0030.2\032\014\n\nRequestMap\032b\n\tAdjustPID\022\t\n\001p"
    "\030\001 \002(\002\022\t\n\001i\030\002 \002(\002\022\t\n\001d\030\003 \002(\002\022\027\n\017velocity"
    "_offset\030\004 \002(\002\022\033\n\023velocity_multiplier\030\005 \002"
    "(\002\"\204\001\n\004Type\022\021\n\rTELEOPERATION\020\001\022\020\n\014SET_AU"
    "TONOMY\020\002\022\021\n\rSTEERING_MODE\020\003\022\020\n\014DEFINE_RO"
    "UTE\020\004\022\017\n\013REQUEST_MAP\020\005\022\016\n\nADJUST_PID\020\006\022\021"
    "\n\rADJUST_WHEELS\020\007", 1617);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "Telecommand.proto", &protobuf_RegisterTypes);
  Telecommand::default_instance_ = new Telecommand();
  Telecommand_Teleoperation::default_instance_ = new Telecommand_Teleoperation();
  Telecommand_Autonomy::default_instance_ = new Telecommand_Autonomy();
  Telecommand_SteeringMode::default_instance_ = new Telecommand_SteeringMode();
  Telecommand_SteeringMode_AckermannSteeringData::default_instance_ = new Telecommand_SteeringMode_AckermannSteeringData();
  Telecommand_SteeringMode_TurnInSpotSteeringData::default_instance_ = new Telecommand_SteeringMode_TurnInSpotSteeringData();
  Telecommand_SteeringMode_CrabSteeringData::default_instance_ = new Telecommand_SteeringMode_CrabSteeringData();
  Telecommand_DefineRoute::default_instance_ = new Telecommand_DefineRoute();
  Telecommand_RequestMap::default_instance_ = new Telecommand_RequestMap();
  Telecommand_AdjustPID::default_instance_ = new Telecommand_AdjustPID();
  Telecommand::default_instance_->InitAsDefaultInstance();
  Telecommand_Teleoperation::default_instance_->InitAsDefaultInstance();
  Telecommand_Autonomy::default_instance_->InitAsDefaultInstance();
  Telecommand_SteeringMode::default_instance_->InitAsDefaultInstance();
  Telecommand_SteeringMode_AckermannSteeringData::default_instance_->InitAsDefaultInstance();
  Telecommand_SteeringMode_TurnInSpotSteeringData::default_instance_->InitAsDefaultInstance();
  Telecommand_SteeringMode_CrabSteeringData::default_instance_->InitAsDefaultInstance();
  Telecommand_DefineRoute::default_instance_->InitAsDefaultInstance();
  Telecommand_RequestMap::default_instance_->InitAsDefaultInstance();
  Telecommand_AdjustPID::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Telecommand_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Telecommand_2eproto {
  StaticDescriptorInitializer_Telecommand_2eproto() {
    protobuf_AddDesc_Telecommand_2eproto();
  }
} static_descriptor_initializer_Telecommand_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* Telecommand_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Telecommand_Type_descriptor_;
}
bool Telecommand_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Telecommand_Type Telecommand::TELEOPERATION;
const Telecommand_Type Telecommand::SET_AUTONOMY;
const Telecommand_Type Telecommand::STEERING_MODE;
const Telecommand_Type Telecommand::DEFINE_ROUTE;
const Telecommand_Type Telecommand::REQUEST_MAP;
const Telecommand_Type Telecommand::ADJUST_PID;
const Telecommand_Type Telecommand::ADJUST_WHEELS;
const Telecommand_Type Telecommand::Type_MIN;
const Telecommand_Type Telecommand::Type_MAX;
const int Telecommand::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Telecommand_Teleoperation::kForwardFieldNumber;
const int Telecommand_Teleoperation::kBackwardFieldNumber;
const int Telecommand_Teleoperation::kLeftFieldNumber;
const int Telecommand_Teleoperation::kRightFieldNumber;
#endif  // !_MSC_VER

Telecommand_Teleoperation::Telecommand_Teleoperation()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Telecommand_Teleoperation::InitAsDefaultInstance() {
}

Telecommand_Teleoperation::Telecommand_Teleoperation(const Telecommand_Teleoperation& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Telecommand_Teleoperation::SharedCtor() {
  _cached_size_ = 0;
  forward_ = false;
  backward_ = false;
  left_ = false;
  right_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Telecommand_Teleoperation::~Telecommand_Teleoperation() {
  SharedDtor();
}

void Telecommand_Teleoperation::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Telecommand_Teleoperation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Telecommand_Teleoperation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Telecommand_Teleoperation_descriptor_;
}

const Telecommand_Teleoperation& Telecommand_Teleoperation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Telecommand_2eproto();
  return *default_instance_;
}

Telecommand_Teleoperation* Telecommand_Teleoperation::default_instance_ = NULL;

Telecommand_Teleoperation* Telecommand_Teleoperation::New() const {
  return new Telecommand_Teleoperation;
}

void Telecommand_Teleoperation::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    forward_ = false;
    backward_ = false;
    left_ = false;
    right_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Telecommand_Teleoperation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool forward = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &forward_)));
          set_has_forward();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_backward;
        break;
      }

      // required bool backward = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_backward:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &backward_)));
          set_has_backward();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_left;
        break;
      }

      // required bool left = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_left:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &left_)));
          set_has_left();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_right;
        break;
      }

      // required bool right = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_right:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &right_)));
          set_has_right();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Telecommand_Teleoperation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool forward = 1;
  if (has_forward()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->forward(), output);
  }

  // required bool backward = 2;
  if (has_backward()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->backward(), output);
  }

  // required bool left = 3;
  if (has_left()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->left(), output);
  }

  // required bool right = 4;
  if (has_right()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->right(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Telecommand_Teleoperation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool forward = 1;
  if (has_forward()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->forward(), target);
  }

  // required bool backward = 2;
  if (has_backward()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->backward(), target);
  }

  // required bool left = 3;
  if (has_left()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->left(), target);
  }

  // required bool right = 4;
  if (has_right()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->right(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Telecommand_Teleoperation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool forward = 1;
    if (has_forward()) {
      total_size += 1 + 1;
    }

    // required bool backward = 2;
    if (has_backward()) {
      total_size += 1 + 1;
    }

    // required bool left = 3;
    if (has_left()) {
      total_size += 1 + 1;
    }

    // required bool right = 4;
    if (has_right()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Telecommand_Teleoperation::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Telecommand_Teleoperation* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Telecommand_Teleoperation*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Telecommand_Teleoperation::MergeFrom(const Telecommand_Teleoperation& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_forward()) {
      set_forward(from.forward());
    }
    if (from.has_backward()) {
      set_backward(from.backward());
    }
    if (from.has_left()) {
      set_left(from.left());
    }
    if (from.has_right()) {
      set_right(from.right());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Telecommand_Teleoperation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Telecommand_Teleoperation::CopyFrom(const Telecommand_Teleoperation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Telecommand_Teleoperation::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void Telecommand_Teleoperation::Swap(Telecommand_Teleoperation* other) {
  if (other != this) {
    std::swap(forward_, other->forward_);
    std::swap(backward_, other->backward_);
    std::swap(left_, other->left_);
    std::swap(right_, other->right_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Telecommand_Teleoperation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Telecommand_Teleoperation_descriptor_;
  metadata.reflection = Telecommand_Teleoperation_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Telecommand_Autonomy::kEnabledFieldNumber;
#endif  // !_MSC_VER

Telecommand_Autonomy::Telecommand_Autonomy()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Telecommand_Autonomy::InitAsDefaultInstance() {
}

Telecommand_Autonomy::Telecommand_Autonomy(const Telecommand_Autonomy& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Telecommand_Autonomy::SharedCtor() {
  _cached_size_ = 0;
  enabled_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Telecommand_Autonomy::~Telecommand_Autonomy() {
  SharedDtor();
}

void Telecommand_Autonomy::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Telecommand_Autonomy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Telecommand_Autonomy::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Telecommand_Autonomy_descriptor_;
}

const Telecommand_Autonomy& Telecommand_Autonomy::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Telecommand_2eproto();
  return *default_instance_;
}

Telecommand_Autonomy* Telecommand_Autonomy::default_instance_ = NULL;

Telecommand_Autonomy* Telecommand_Autonomy::New() const {
  return new Telecommand_Autonomy;
}

void Telecommand_Autonomy::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    enabled_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Telecommand_Autonomy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool enabled = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enabled_)));
          set_has_enabled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Telecommand_Autonomy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool enabled = 1;
  if (has_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->enabled(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Telecommand_Autonomy::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool enabled = 1;
  if (has_enabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->enabled(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Telecommand_Autonomy::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool enabled = 1;
    if (has_enabled()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Telecommand_Autonomy::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Telecommand_Autonomy* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Telecommand_Autonomy*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Telecommand_Autonomy::MergeFrom(const Telecommand_Autonomy& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_enabled()) {
      set_enabled(from.enabled());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Telecommand_Autonomy::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Telecommand_Autonomy::CopyFrom(const Telecommand_Autonomy& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Telecommand_Autonomy::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Telecommand_Autonomy::Swap(Telecommand_Autonomy* other) {
  if (other != this) {
    std::swap(enabled_, other->enabled_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Telecommand_Autonomy::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Telecommand_Autonomy_descriptor_;
  metadata.reflection = Telecommand_Autonomy_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Telecommand_SteeringMode_AckermannSteeringData::kMaxLinearVelocityFieldNumber;
const int Telecommand_SteeringMode_AckermannSteeringData::kBezierCurveSegmentsFieldNumber;
#endif  // !_MSC_VER

Telecommand_SteeringMode_AckermannSteeringData::Telecommand_SteeringMode_AckermannSteeringData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Telecommand_SteeringMode_AckermannSteeringData::InitAsDefaultInstance() {
}

Telecommand_SteeringMode_AckermannSteeringData::Telecommand_SteeringMode_AckermannSteeringData(const Telecommand_SteeringMode_AckermannSteeringData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Telecommand_SteeringMode_AckermannSteeringData::SharedCtor() {
  _cached_size_ = 0;
  max_linear_velocity_ = 0.33f;
  bezier_curve_segments_ = 20;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Telecommand_SteeringMode_AckermannSteeringData::~Telecommand_SteeringMode_AckermannSteeringData() {
  SharedDtor();
}

void Telecommand_SteeringMode_AckermannSteeringData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Telecommand_SteeringMode_AckermannSteeringData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Telecommand_SteeringMode_AckermannSteeringData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Telecommand_SteeringMode_AckermannSteeringData_descriptor_;
}

const Telecommand_SteeringMode_AckermannSteeringData& Telecommand_SteeringMode_AckermannSteeringData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Telecommand_2eproto();
  return *default_instance_;
}

Telecommand_SteeringMode_AckermannSteeringData* Telecommand_SteeringMode_AckermannSteeringData::default_instance_ = NULL;

Telecommand_SteeringMode_AckermannSteeringData* Telecommand_SteeringMode_AckermannSteeringData::New() const {
  return new Telecommand_SteeringMode_AckermannSteeringData;
}

void Telecommand_SteeringMode_AckermannSteeringData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    max_linear_velocity_ = 0.33f;
    bezier_curve_segments_ = 20;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Telecommand_SteeringMode_AckermannSteeringData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float max_linear_velocity = 1 [default = 0.33];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_linear_velocity_)));
          set_has_max_linear_velocity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_bezier_curve_segments;
        break;
      }

      // optional int32 bezier_curve_segments = 2 [default = 20];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bezier_curve_segments:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bezier_curve_segments_)));
          set_has_bezier_curve_segments();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Telecommand_SteeringMode_AckermannSteeringData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float max_linear_velocity = 1 [default = 0.33];
  if (has_max_linear_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->max_linear_velocity(), output);
  }

  // optional int32 bezier_curve_segments = 2 [default = 20];
  if (has_bezier_curve_segments()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->bezier_curve_segments(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Telecommand_SteeringMode_AckermannSteeringData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional float max_linear_velocity = 1 [default = 0.33];
  if (has_max_linear_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->max_linear_velocity(), target);
  }

  // optional int32 bezier_curve_segments = 2 [default = 20];
  if (has_bezier_curve_segments()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->bezier_curve_segments(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Telecommand_SteeringMode_AckermannSteeringData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float max_linear_velocity = 1 [default = 0.33];
    if (has_max_linear_velocity()) {
      total_size += 1 + 4;
    }

    // optional int32 bezier_curve_segments = 2 [default = 20];
    if (has_bezier_curve_segments()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bezier_curve_segments());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Telecommand_SteeringMode_AckermannSteeringData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Telecommand_SteeringMode_AckermannSteeringData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Telecommand_SteeringMode_AckermannSteeringData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Telecommand_SteeringMode_AckermannSteeringData::MergeFrom(const Telecommand_SteeringMode_AckermannSteeringData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_max_linear_velocity()) {
      set_max_linear_velocity(from.max_linear_velocity());
    }
    if (from.has_bezier_curve_segments()) {
      set_bezier_curve_segments(from.bezier_curve_segments());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Telecommand_SteeringMode_AckermannSteeringData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Telecommand_SteeringMode_AckermannSteeringData::CopyFrom(const Telecommand_SteeringMode_AckermannSteeringData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Telecommand_SteeringMode_AckermannSteeringData::IsInitialized() const {

  return true;
}

void Telecommand_SteeringMode_AckermannSteeringData::Swap(Telecommand_SteeringMode_AckermannSteeringData* other) {
  if (other != this) {
    std::swap(max_linear_velocity_, other->max_linear_velocity_);
    std::swap(bezier_curve_segments_, other->bezier_curve_segments_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Telecommand_SteeringMode_AckermannSteeringData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Telecommand_SteeringMode_AckermannSteeringData_descriptor_;
  metadata.reflection = Telecommand_SteeringMode_AckermannSteeringData_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

Telecommand_SteeringMode_TurnInSpotSteeringData::Telecommand_SteeringMode_TurnInSpotSteeringData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Telecommand_SteeringMode_TurnInSpotSteeringData::InitAsDefaultInstance() {
}

Telecommand_SteeringMode_TurnInSpotSteeringData::Telecommand_SteeringMode_TurnInSpotSteeringData(const Telecommand_SteeringMode_TurnInSpotSteeringData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Telecommand_SteeringMode_TurnInSpotSteeringData::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Telecommand_SteeringMode_TurnInSpotSteeringData::~Telecommand_SteeringMode_TurnInSpotSteeringData() {
  SharedDtor();
}

void Telecommand_SteeringMode_TurnInSpotSteeringData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Telecommand_SteeringMode_TurnInSpotSteeringData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Telecommand_SteeringMode_TurnInSpotSteeringData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Telecommand_SteeringMode_TurnInSpotSteeringData_descriptor_;
}

const Telecommand_SteeringMode_TurnInSpotSteeringData& Telecommand_SteeringMode_TurnInSpotSteeringData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Telecommand_2eproto();
  return *default_instance_;
}

Telecommand_SteeringMode_TurnInSpotSteeringData* Telecommand_SteeringMode_TurnInSpotSteeringData::default_instance_ = NULL;

Telecommand_SteeringMode_TurnInSpotSteeringData* Telecommand_SteeringMode_TurnInSpotSteeringData::New() const {
  return new Telecommand_SteeringMode_TurnInSpotSteeringData;
}

void Telecommand_SteeringMode_TurnInSpotSteeringData::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Telecommand_SteeringMode_TurnInSpotSteeringData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void Telecommand_SteeringMode_TurnInSpotSteeringData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Telecommand_SteeringMode_TurnInSpotSteeringData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Telecommand_SteeringMode_TurnInSpotSteeringData::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Telecommand_SteeringMode_TurnInSpotSteeringData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Telecommand_SteeringMode_TurnInSpotSteeringData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Telecommand_SteeringMode_TurnInSpotSteeringData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Telecommand_SteeringMode_TurnInSpotSteeringData::MergeFrom(const Telecommand_SteeringMode_TurnInSpotSteeringData& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Telecommand_SteeringMode_TurnInSpotSteeringData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Telecommand_SteeringMode_TurnInSpotSteeringData::CopyFrom(const Telecommand_SteeringMode_TurnInSpotSteeringData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Telecommand_SteeringMode_TurnInSpotSteeringData::IsInitialized() const {

  return true;
}

void Telecommand_SteeringMode_TurnInSpotSteeringData::Swap(Telecommand_SteeringMode_TurnInSpotSteeringData* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Telecommand_SteeringMode_TurnInSpotSteeringData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Telecommand_SteeringMode_TurnInSpotSteeringData_descriptor_;
  metadata.reflection = Telecommand_SteeringMode_TurnInSpotSteeringData_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

Telecommand_SteeringMode_CrabSteeringData::Telecommand_SteeringMode_CrabSteeringData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Telecommand_SteeringMode_CrabSteeringData::InitAsDefaultInstance() {
}

Telecommand_SteeringMode_CrabSteeringData::Telecommand_SteeringMode_CrabSteeringData(const Telecommand_SteeringMode_CrabSteeringData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Telecommand_SteeringMode_CrabSteeringData::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Telecommand_SteeringMode_CrabSteeringData::~Telecommand_SteeringMode_CrabSteeringData() {
  SharedDtor();
}

void Telecommand_SteeringMode_CrabSteeringData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Telecommand_SteeringMode_CrabSteeringData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Telecommand_SteeringMode_CrabSteeringData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Telecommand_SteeringMode_CrabSteeringData_descriptor_;
}

const Telecommand_SteeringMode_CrabSteeringData& Telecommand_SteeringMode_CrabSteeringData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Telecommand_2eproto();
  return *default_instance_;
}

Telecommand_SteeringMode_CrabSteeringData* Telecommand_SteeringMode_CrabSteeringData::default_instance_ = NULL;

Telecommand_SteeringMode_CrabSteeringData* Telecommand_SteeringMode_CrabSteeringData::New() const {
  return new Telecommand_SteeringMode_CrabSteeringData;
}

void Telecommand_SteeringMode_CrabSteeringData::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Telecommand_SteeringMode_CrabSteeringData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void Telecommand_SteeringMode_CrabSteeringData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Telecommand_SteeringMode_CrabSteeringData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Telecommand_SteeringMode_CrabSteeringData::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Telecommand_SteeringMode_CrabSteeringData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Telecommand_SteeringMode_CrabSteeringData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Telecommand_SteeringMode_CrabSteeringData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Telecommand_SteeringMode_CrabSteeringData::MergeFrom(const Telecommand_SteeringMode_CrabSteeringData& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Telecommand_SteeringMode_CrabSteeringData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Telecommand_SteeringMode_CrabSteeringData::CopyFrom(const Telecommand_SteeringMode_CrabSteeringData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Telecommand_SteeringMode_CrabSteeringData::IsInitialized() const {

  return true;
}

void Telecommand_SteeringMode_CrabSteeringData::Swap(Telecommand_SteeringMode_CrabSteeringData* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Telecommand_SteeringMode_CrabSteeringData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Telecommand_SteeringMode_CrabSteeringData_descriptor_;
  metadata.reflection = Telecommand_SteeringMode_CrabSteeringData_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Telecommand_SteeringMode::kTypeFieldNumber;
const int Telecommand_SteeringMode::kAckermannSteeringDataFieldNumber;
const int Telecommand_SteeringMode::kTurnInSpotSteeringDataFieldNumber;
const int Telecommand_SteeringMode::kCrabSteeringDataFieldNumber;
#endif  // !_MSC_VER

Telecommand_SteeringMode::Telecommand_SteeringMode()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Telecommand_SteeringMode::InitAsDefaultInstance() {
  ackermann_steering_data_ = const_cast< ::lunabotics::proto::Telecommand_SteeringMode_AckermannSteeringData*>(&::lunabotics::proto::Telecommand_SteeringMode_AckermannSteeringData::default_instance());
  turn_in_spot_steering_data_ = const_cast< ::lunabotics::proto::Telecommand_SteeringMode_TurnInSpotSteeringData*>(&::lunabotics::proto::Telecommand_SteeringMode_TurnInSpotSteeringData::default_instance());
  crab_steering_data_ = const_cast< ::lunabotics::proto::Telecommand_SteeringMode_CrabSteeringData*>(&::lunabotics::proto::Telecommand_SteeringMode_CrabSteeringData::default_instance());
}

Telecommand_SteeringMode::Telecommand_SteeringMode(const Telecommand_SteeringMode& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Telecommand_SteeringMode::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  ackermann_steering_data_ = NULL;
  turn_in_spot_steering_data_ = NULL;
  crab_steering_data_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Telecommand_SteeringMode::~Telecommand_SteeringMode() {
  SharedDtor();
}

void Telecommand_SteeringMode::SharedDtor() {
  if (this != default_instance_) {
    delete ackermann_steering_data_;
    delete turn_in_spot_steering_data_;
    delete crab_steering_data_;
  }
}

void Telecommand_SteeringMode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Telecommand_SteeringMode::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Telecommand_SteeringMode_descriptor_;
}

const Telecommand_SteeringMode& Telecommand_SteeringMode::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Telecommand_2eproto();
  return *default_instance_;
}

Telecommand_SteeringMode* Telecommand_SteeringMode::default_instance_ = NULL;

Telecommand_SteeringMode* Telecommand_SteeringMode::New() const {
  return new Telecommand_SteeringMode;
}

void Telecommand_SteeringMode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_ackermann_steering_data()) {
      if (ackermann_steering_data_ != NULL) ackermann_steering_data_->::lunabotics::proto::Telecommand_SteeringMode_AckermannSteeringData::Clear();
    }
    if (has_turn_in_spot_steering_data()) {
      if (turn_in_spot_steering_data_ != NULL) turn_in_spot_steering_data_->::lunabotics::proto::Telecommand_SteeringMode_TurnInSpotSteeringData::Clear();
    }
    if (has_crab_steering_data()) {
      if (crab_steering_data_ != NULL) crab_steering_data_->::lunabotics::proto::Telecommand_SteeringMode_CrabSteeringData::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Telecommand_SteeringMode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .lunabotics.proto.SteeringModeType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::lunabotics::proto::SteeringModeType_IsValid(value)) {
            set_type(static_cast< ::lunabotics::proto::SteeringModeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_ackermann_steering_data;
        break;
      }

      // optional .lunabotics.proto.Telecommand.SteeringMode.AckermannSteeringData ackermann_steering_data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ackermann_steering_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ackermann_steering_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_turn_in_spot_steering_data;
        break;
      }

      // optional .lunabotics.proto.Telecommand.SteeringMode.TurnInSpotSteeringData turn_in_spot_steering_data = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_turn_in_spot_steering_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_turn_in_spot_steering_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_crab_steering_data;
        break;
      }

      // optional .lunabotics.proto.Telecommand.SteeringMode.CrabSteeringData crab_steering_data = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_crab_steering_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_crab_steering_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Telecommand_SteeringMode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .lunabotics.proto.SteeringModeType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .lunabotics.proto.Telecommand.SteeringMode.AckermannSteeringData ackermann_steering_data = 2;
  if (has_ackermann_steering_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->ackermann_steering_data(), output);
  }

  // optional .lunabotics.proto.Telecommand.SteeringMode.TurnInSpotSteeringData turn_in_spot_steering_data = 3;
  if (has_turn_in_spot_steering_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->turn_in_spot_steering_data(), output);
  }

  // optional .lunabotics.proto.Telecommand.SteeringMode.CrabSteeringData crab_steering_data = 4;
  if (has_crab_steering_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->crab_steering_data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Telecommand_SteeringMode::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .lunabotics.proto.SteeringModeType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .lunabotics.proto.Telecommand.SteeringMode.AckermannSteeringData ackermann_steering_data = 2;
  if (has_ackermann_steering_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->ackermann_steering_data(), target);
  }

  // optional .lunabotics.proto.Telecommand.SteeringMode.TurnInSpotSteeringData turn_in_spot_steering_data = 3;
  if (has_turn_in_spot_steering_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->turn_in_spot_steering_data(), target);
  }

  // optional .lunabotics.proto.Telecommand.SteeringMode.CrabSteeringData crab_steering_data = 4;
  if (has_crab_steering_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->crab_steering_data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Telecommand_SteeringMode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .lunabotics.proto.SteeringModeType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .lunabotics.proto.Telecommand.SteeringMode.AckermannSteeringData ackermann_steering_data = 2;
    if (has_ackermann_steering_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ackermann_steering_data());
    }

    // optional .lunabotics.proto.Telecommand.SteeringMode.TurnInSpotSteeringData turn_in_spot_steering_data = 3;
    if (has_turn_in_spot_steering_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->turn_in_spot_steering_data());
    }

    // optional .lunabotics.proto.Telecommand.SteeringMode.CrabSteeringData crab_steering_data = 4;
    if (has_crab_steering_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->crab_steering_data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Telecommand_SteeringMode::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Telecommand_SteeringMode* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Telecommand_SteeringMode*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Telecommand_SteeringMode::MergeFrom(const Telecommand_SteeringMode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_ackermann_steering_data()) {
      mutable_ackermann_steering_data()->::lunabotics::proto::Telecommand_SteeringMode_AckermannSteeringData::MergeFrom(from.ackermann_steering_data());
    }
    if (from.has_turn_in_spot_steering_data()) {
      mutable_turn_in_spot_steering_data()->::lunabotics::proto::Telecommand_SteeringMode_TurnInSpotSteeringData::MergeFrom(from.turn_in_spot_steering_data());
    }
    if (from.has_crab_steering_data()) {
      mutable_crab_steering_data()->::lunabotics::proto::Telecommand_SteeringMode_CrabSteeringData::MergeFrom(from.crab_steering_data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Telecommand_SteeringMode::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Telecommand_SteeringMode::CopyFrom(const Telecommand_SteeringMode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Telecommand_SteeringMode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Telecommand_SteeringMode::Swap(Telecommand_SteeringMode* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(ackermann_steering_data_, other->ackermann_steering_data_);
    std::swap(turn_in_spot_steering_data_, other->turn_in_spot_steering_data_);
    std::swap(crab_steering_data_, other->crab_steering_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Telecommand_SteeringMode::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Telecommand_SteeringMode_descriptor_;
  metadata.reflection = Telecommand_SteeringMode_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Telecommand_DefineRoute::kGoalFieldNumber;
const int Telecommand_DefineRoute::kHeadingAccuracyFieldNumber;
const int Telecommand_DefineRoute::kPositionAccuracyFieldNumber;
#endif  // !_MSC_VER

Telecommand_DefineRoute::Telecommand_DefineRoute()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Telecommand_DefineRoute::InitAsDefaultInstance() {
  goal_ = const_cast< ::lunabotics::proto::Point*>(&::lunabotics::proto::Point::default_instance());
}

Telecommand_DefineRoute::Telecommand_DefineRoute(const Telecommand_DefineRoute& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Telecommand_DefineRoute::SharedCtor() {
  _cached_size_ = 0;
  goal_ = NULL;
  heading_accuracy_ = 0.4f;
  position_accuracy_ = 0.2f;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Telecommand_DefineRoute::~Telecommand_DefineRoute() {
  SharedDtor();
}

void Telecommand_DefineRoute::SharedDtor() {
  if (this != default_instance_) {
    delete goal_;
  }
}

void Telecommand_DefineRoute::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Telecommand_DefineRoute::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Telecommand_DefineRoute_descriptor_;
}

const Telecommand_DefineRoute& Telecommand_DefineRoute::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Telecommand_2eproto();
  return *default_instance_;
}

Telecommand_DefineRoute* Telecommand_DefineRoute::default_instance_ = NULL;

Telecommand_DefineRoute* Telecommand_DefineRoute::New() const {
  return new Telecommand_DefineRoute;
}

void Telecommand_DefineRoute::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_goal()) {
      if (goal_ != NULL) goal_->::lunabotics::proto::Point::Clear();
    }
    heading_accuracy_ = 0.4f;
    position_accuracy_ = 0.2f;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Telecommand_DefineRoute::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .lunabotics.proto.Point goal = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_goal()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_heading_accuracy;
        break;
      }

      // optional float heading_accuracy = 2 [default = 0.4];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_heading_accuracy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &heading_accuracy_)));
          set_has_heading_accuracy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_position_accuracy;
        break;
      }

      // optional float position_accuracy = 3 [default = 0.2];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_position_accuracy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &position_accuracy_)));
          set_has_position_accuracy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Telecommand_DefineRoute::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .lunabotics.proto.Point goal = 1;
  if (has_goal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->goal(), output);
  }

  // optional float heading_accuracy = 2 [default = 0.4];
  if (has_heading_accuracy()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->heading_accuracy(), output);
  }

  // optional float position_accuracy = 3 [default = 0.2];
  if (has_position_accuracy()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->position_accuracy(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Telecommand_DefineRoute::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .lunabotics.proto.Point goal = 1;
  if (has_goal()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->goal(), target);
  }

  // optional float heading_accuracy = 2 [default = 0.4];
  if (has_heading_accuracy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->heading_accuracy(), target);
  }

  // optional float position_accuracy = 3 [default = 0.2];
  if (has_position_accuracy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->position_accuracy(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Telecommand_DefineRoute::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .lunabotics.proto.Point goal = 1;
    if (has_goal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->goal());
    }

    // optional float heading_accuracy = 2 [default = 0.4];
    if (has_heading_accuracy()) {
      total_size += 1 + 4;
    }

    // optional float position_accuracy = 3 [default = 0.2];
    if (has_position_accuracy()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Telecommand_DefineRoute::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Telecommand_DefineRoute* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Telecommand_DefineRoute*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Telecommand_DefineRoute::MergeFrom(const Telecommand_DefineRoute& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_goal()) {
      mutable_goal()->::lunabotics::proto::Point::MergeFrom(from.goal());
    }
    if (from.has_heading_accuracy()) {
      set_heading_accuracy(from.heading_accuracy());
    }
    if (from.has_position_accuracy()) {
      set_position_accuracy(from.position_accuracy());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Telecommand_DefineRoute::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Telecommand_DefineRoute::CopyFrom(const Telecommand_DefineRoute& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Telecommand_DefineRoute::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_goal()) {
    if (!this->goal().IsInitialized()) return false;
  }
  return true;
}

void Telecommand_DefineRoute::Swap(Telecommand_DefineRoute* other) {
  if (other != this) {
    std::swap(goal_, other->goal_);
    std::swap(heading_accuracy_, other->heading_accuracy_);
    std::swap(position_accuracy_, other->position_accuracy_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Telecommand_DefineRoute::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Telecommand_DefineRoute_descriptor_;
  metadata.reflection = Telecommand_DefineRoute_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

Telecommand_RequestMap::Telecommand_RequestMap()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Telecommand_RequestMap::InitAsDefaultInstance() {
}

Telecommand_RequestMap::Telecommand_RequestMap(const Telecommand_RequestMap& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Telecommand_RequestMap::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Telecommand_RequestMap::~Telecommand_RequestMap() {
  SharedDtor();
}

void Telecommand_RequestMap::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Telecommand_RequestMap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Telecommand_RequestMap::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Telecommand_RequestMap_descriptor_;
}

const Telecommand_RequestMap& Telecommand_RequestMap::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Telecommand_2eproto();
  return *default_instance_;
}

Telecommand_RequestMap* Telecommand_RequestMap::default_instance_ = NULL;

Telecommand_RequestMap* Telecommand_RequestMap::New() const {
  return new Telecommand_RequestMap;
}

void Telecommand_RequestMap::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Telecommand_RequestMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void Telecommand_RequestMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Telecommand_RequestMap::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Telecommand_RequestMap::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Telecommand_RequestMap::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Telecommand_RequestMap* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Telecommand_RequestMap*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Telecommand_RequestMap::MergeFrom(const Telecommand_RequestMap& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Telecommand_RequestMap::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Telecommand_RequestMap::CopyFrom(const Telecommand_RequestMap& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Telecommand_RequestMap::IsInitialized() const {

  return true;
}

void Telecommand_RequestMap::Swap(Telecommand_RequestMap* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Telecommand_RequestMap::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Telecommand_RequestMap_descriptor_;
  metadata.reflection = Telecommand_RequestMap_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Telecommand_AdjustPID::kPFieldNumber;
const int Telecommand_AdjustPID::kIFieldNumber;
const int Telecommand_AdjustPID::kDFieldNumber;
const int Telecommand_AdjustPID::kVelocityOffsetFieldNumber;
const int Telecommand_AdjustPID::kVelocityMultiplierFieldNumber;
#endif  // !_MSC_VER

Telecommand_AdjustPID::Telecommand_AdjustPID()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Telecommand_AdjustPID::InitAsDefaultInstance() {
}

Telecommand_AdjustPID::Telecommand_AdjustPID(const Telecommand_AdjustPID& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Telecommand_AdjustPID::SharedCtor() {
  _cached_size_ = 0;
  p_ = 0;
  i_ = 0;
  d_ = 0;
  velocity_offset_ = 0;
  velocity_multiplier_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Telecommand_AdjustPID::~Telecommand_AdjustPID() {
  SharedDtor();
}

void Telecommand_AdjustPID::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Telecommand_AdjustPID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Telecommand_AdjustPID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Telecommand_AdjustPID_descriptor_;
}

const Telecommand_AdjustPID& Telecommand_AdjustPID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Telecommand_2eproto();
  return *default_instance_;
}

Telecommand_AdjustPID* Telecommand_AdjustPID::default_instance_ = NULL;

Telecommand_AdjustPID* Telecommand_AdjustPID::New() const {
  return new Telecommand_AdjustPID;
}

void Telecommand_AdjustPID::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    p_ = 0;
    i_ = 0;
    d_ = 0;
    velocity_offset_ = 0;
    velocity_multiplier_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Telecommand_AdjustPID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float p = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &p_)));
          set_has_p();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_i;
        break;
      }

      // required float i = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_i:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &i_)));
          set_has_i();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_d;
        break;
      }

      // required float d = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_d:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &d_)));
          set_has_d();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_velocity_offset;
        break;
      }

      // required float velocity_offset = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_velocity_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &velocity_offset_)));
          set_has_velocity_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_velocity_multiplier;
        break;
      }

      // required float velocity_multiplier = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_velocity_multiplier:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &velocity_multiplier_)));
          set_has_velocity_multiplier();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Telecommand_AdjustPID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float p = 1;
  if (has_p()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->p(), output);
  }

  // required float i = 2;
  if (has_i()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->i(), output);
  }

  // required float d = 3;
  if (has_d()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->d(), output);
  }

  // required float velocity_offset = 4;
  if (has_velocity_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->velocity_offset(), output);
  }

  // required float velocity_multiplier = 5;
  if (has_velocity_multiplier()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->velocity_multiplier(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Telecommand_AdjustPID::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float p = 1;
  if (has_p()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->p(), target);
  }

  // required float i = 2;
  if (has_i()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->i(), target);
  }

  // required float d = 3;
  if (has_d()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->d(), target);
  }

  // required float velocity_offset = 4;
  if (has_velocity_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->velocity_offset(), target);
  }

  // required float velocity_multiplier = 5;
  if (has_velocity_multiplier()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->velocity_multiplier(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Telecommand_AdjustPID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float p = 1;
    if (has_p()) {
      total_size += 1 + 4;
    }

    // required float i = 2;
    if (has_i()) {
      total_size += 1 + 4;
    }

    // required float d = 3;
    if (has_d()) {
      total_size += 1 + 4;
    }

    // required float velocity_offset = 4;
    if (has_velocity_offset()) {
      total_size += 1 + 4;
    }

    // required float velocity_multiplier = 5;
    if (has_velocity_multiplier()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Telecommand_AdjustPID::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Telecommand_AdjustPID* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Telecommand_AdjustPID*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Telecommand_AdjustPID::MergeFrom(const Telecommand_AdjustPID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_p()) {
      set_p(from.p());
    }
    if (from.has_i()) {
      set_i(from.i());
    }
    if (from.has_d()) {
      set_d(from.d());
    }
    if (from.has_velocity_offset()) {
      set_velocity_offset(from.velocity_offset());
    }
    if (from.has_velocity_multiplier()) {
      set_velocity_multiplier(from.velocity_multiplier());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Telecommand_AdjustPID::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Telecommand_AdjustPID::CopyFrom(const Telecommand_AdjustPID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Telecommand_AdjustPID::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void Telecommand_AdjustPID::Swap(Telecommand_AdjustPID* other) {
  if (other != this) {
    std::swap(p_, other->p_);
    std::swap(i_, other->i_);
    std::swap(d_, other->d_);
    std::swap(velocity_offset_, other->velocity_offset_);
    std::swap(velocity_multiplier_, other->velocity_multiplier_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Telecommand_AdjustPID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Telecommand_AdjustPID_descriptor_;
  metadata.reflection = Telecommand_AdjustPID_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Telecommand::kTypeFieldNumber;
const int Telecommand::kTeleoperationDataFieldNumber;
const int Telecommand::kAutonomyDataFieldNumber;
const int Telecommand::kSteeringModeDataFieldNumber;
const int Telecommand::kDefineRouteDataFieldNumber;
const int Telecommand::kRequestMapDataFieldNumber;
const int Telecommand::kAdjustPidDataFieldNumber;
const int Telecommand::kAllWheelControlDataFieldNumber;
#endif  // !_MSC_VER

Telecommand::Telecommand()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Telecommand::InitAsDefaultInstance() {
  teleoperation_data_ = const_cast< ::lunabotics::proto::Telecommand_Teleoperation*>(&::lunabotics::proto::Telecommand_Teleoperation::default_instance());
  autonomy_data_ = const_cast< ::lunabotics::proto::Telecommand_Autonomy*>(&::lunabotics::proto::Telecommand_Autonomy::default_instance());
  steering_mode_data_ = const_cast< ::lunabotics::proto::Telecommand_SteeringMode*>(&::lunabotics::proto::Telecommand_SteeringMode::default_instance());
  define_route_data_ = const_cast< ::lunabotics::proto::Telecommand_DefineRoute*>(&::lunabotics::proto::Telecommand_DefineRoute::default_instance());
  request_map_data_ = const_cast< ::lunabotics::proto::Telecommand_RequestMap*>(&::lunabotics::proto::Telecommand_RequestMap::default_instance());
  adjust_pid_data_ = const_cast< ::lunabotics::proto::Telecommand_AdjustPID*>(&::lunabotics::proto::Telecommand_AdjustPID::default_instance());
  all_wheel_control_data_ = const_cast< ::lunabotics::proto::AllWheelControl*>(&::lunabotics::proto::AllWheelControl::default_instance());
}

Telecommand::Telecommand(const Telecommand& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Telecommand::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  teleoperation_data_ = NULL;
  autonomy_data_ = NULL;
  steering_mode_data_ = NULL;
  define_route_data_ = NULL;
  request_map_data_ = NULL;
  adjust_pid_data_ = NULL;
  all_wheel_control_data_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Telecommand::~Telecommand() {
  SharedDtor();
}

void Telecommand::SharedDtor() {
  if (this != default_instance_) {
    delete teleoperation_data_;
    delete autonomy_data_;
    delete steering_mode_data_;
    delete define_route_data_;
    delete request_map_data_;
    delete adjust_pid_data_;
    delete all_wheel_control_data_;
  }
}

void Telecommand::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Telecommand::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Telecommand_descriptor_;
}

const Telecommand& Telecommand::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Telecommand_2eproto();
  return *default_instance_;
}

Telecommand* Telecommand::default_instance_ = NULL;

Telecommand* Telecommand::New() const {
  return new Telecommand;
}

void Telecommand::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_teleoperation_data()) {
      if (teleoperation_data_ != NULL) teleoperation_data_->::lunabotics::proto::Telecommand_Teleoperation::Clear();
    }
    if (has_autonomy_data()) {
      if (autonomy_data_ != NULL) autonomy_data_->::lunabotics::proto::Telecommand_Autonomy::Clear();
    }
    if (has_steering_mode_data()) {
      if (steering_mode_data_ != NULL) steering_mode_data_->::lunabotics::proto::Telecommand_SteeringMode::Clear();
    }
    if (has_define_route_data()) {
      if (define_route_data_ != NULL) define_route_data_->::lunabotics::proto::Telecommand_DefineRoute::Clear();
    }
    if (has_request_map_data()) {
      if (request_map_data_ != NULL) request_map_data_->::lunabotics::proto::Telecommand_RequestMap::Clear();
    }
    if (has_adjust_pid_data()) {
      if (adjust_pid_data_ != NULL) adjust_pid_data_->::lunabotics::proto::Telecommand_AdjustPID::Clear();
    }
    if (has_all_wheel_control_data()) {
      if (all_wheel_control_data_ != NULL) all_wheel_control_data_->::lunabotics::proto::AllWheelControl::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Telecommand::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .lunabotics.proto.Telecommand.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::lunabotics::proto::Telecommand_Type_IsValid(value)) {
            set_type(static_cast< ::lunabotics::proto::Telecommand_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_teleoperation_data;
        break;
      }

      // optional .lunabotics.proto.Telecommand.Teleoperation teleoperation_data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_teleoperation_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_teleoperation_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_autonomy_data;
        break;
      }

      // optional .lunabotics.proto.Telecommand.Autonomy autonomy_data = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_autonomy_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_autonomy_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_steering_mode_data;
        break;
      }

      // optional .lunabotics.proto.Telecommand.SteeringMode steering_mode_data = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_steering_mode_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_steering_mode_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_define_route_data;
        break;
      }

      // optional .lunabotics.proto.Telecommand.DefineRoute define_route_data = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_define_route_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_define_route_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_request_map_data;
        break;
      }

      // optional .lunabotics.proto.Telecommand.RequestMap request_map_data = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_request_map_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_request_map_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_adjust_pid_data;
        break;
      }

      // optional .lunabotics.proto.Telecommand.AdjustPID adjust_pid_data = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_adjust_pid_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_adjust_pid_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_all_wheel_control_data;
        break;
      }

      // optional .lunabotics.proto.AllWheelControl all_wheel_control_data = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_all_wheel_control_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_all_wheel_control_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Telecommand::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .lunabotics.proto.Telecommand.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .lunabotics.proto.Telecommand.Teleoperation teleoperation_data = 2;
  if (has_teleoperation_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->teleoperation_data(), output);
  }

  // optional .lunabotics.proto.Telecommand.Autonomy autonomy_data = 3;
  if (has_autonomy_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->autonomy_data(), output);
  }

  // optional .lunabotics.proto.Telecommand.SteeringMode steering_mode_data = 4;
  if (has_steering_mode_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->steering_mode_data(), output);
  }

  // optional .lunabotics.proto.Telecommand.DefineRoute define_route_data = 5;
  if (has_define_route_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->define_route_data(), output);
  }

  // optional .lunabotics.proto.Telecommand.RequestMap request_map_data = 6;
  if (has_request_map_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->request_map_data(), output);
  }

  // optional .lunabotics.proto.Telecommand.AdjustPID adjust_pid_data = 7;
  if (has_adjust_pid_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->adjust_pid_data(), output);
  }

  // optional .lunabotics.proto.AllWheelControl all_wheel_control_data = 8;
  if (has_all_wheel_control_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->all_wheel_control_data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Telecommand::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .lunabotics.proto.Telecommand.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .lunabotics.proto.Telecommand.Teleoperation teleoperation_data = 2;
  if (has_teleoperation_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->teleoperation_data(), target);
  }

  // optional .lunabotics.proto.Telecommand.Autonomy autonomy_data = 3;
  if (has_autonomy_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->autonomy_data(), target);
  }

  // optional .lunabotics.proto.Telecommand.SteeringMode steering_mode_data = 4;
  if (has_steering_mode_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->steering_mode_data(), target);
  }

  // optional .lunabotics.proto.Telecommand.DefineRoute define_route_data = 5;
  if (has_define_route_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->define_route_data(), target);
  }

  // optional .lunabotics.proto.Telecommand.RequestMap request_map_data = 6;
  if (has_request_map_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->request_map_data(), target);
  }

  // optional .lunabotics.proto.Telecommand.AdjustPID adjust_pid_data = 7;
  if (has_adjust_pid_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->adjust_pid_data(), target);
  }

  // optional .lunabotics.proto.AllWheelControl all_wheel_control_data = 8;
  if (has_all_wheel_control_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->all_wheel_control_data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Telecommand::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .lunabotics.proto.Telecommand.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .lunabotics.proto.Telecommand.Teleoperation teleoperation_data = 2;
    if (has_teleoperation_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->teleoperation_data());
    }

    // optional .lunabotics.proto.Telecommand.Autonomy autonomy_data = 3;
    if (has_autonomy_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->autonomy_data());
    }

    // optional .lunabotics.proto.Telecommand.SteeringMode steering_mode_data = 4;
    if (has_steering_mode_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->steering_mode_data());
    }

    // optional .lunabotics.proto.Telecommand.DefineRoute define_route_data = 5;
    if (has_define_route_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->define_route_data());
    }

    // optional .lunabotics.proto.Telecommand.RequestMap request_map_data = 6;
    if (has_request_map_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->request_map_data());
    }

    // optional .lunabotics.proto.Telecommand.AdjustPID adjust_pid_data = 7;
    if (has_adjust_pid_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->adjust_pid_data());
    }

    // optional .lunabotics.proto.AllWheelControl all_wheel_control_data = 8;
    if (has_all_wheel_control_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->all_wheel_control_data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Telecommand::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Telecommand* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Telecommand*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Telecommand::MergeFrom(const Telecommand& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_teleoperation_data()) {
      mutable_teleoperation_data()->::lunabotics::proto::Telecommand_Teleoperation::MergeFrom(from.teleoperation_data());
    }
    if (from.has_autonomy_data()) {
      mutable_autonomy_data()->::lunabotics::proto::Telecommand_Autonomy::MergeFrom(from.autonomy_data());
    }
    if (from.has_steering_mode_data()) {
      mutable_steering_mode_data()->::lunabotics::proto::Telecommand_SteeringMode::MergeFrom(from.steering_mode_data());
    }
    if (from.has_define_route_data()) {
      mutable_define_route_data()->::lunabotics::proto::Telecommand_DefineRoute::MergeFrom(from.define_route_data());
    }
    if (from.has_request_map_data()) {
      mutable_request_map_data()->::lunabotics::proto::Telecommand_RequestMap::MergeFrom(from.request_map_data());
    }
    if (from.has_adjust_pid_data()) {
      mutable_adjust_pid_data()->::lunabotics::proto::Telecommand_AdjustPID::MergeFrom(from.adjust_pid_data());
    }
    if (from.has_all_wheel_control_data()) {
      mutable_all_wheel_control_data()->::lunabotics::proto::AllWheelControl::MergeFrom(from.all_wheel_control_data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Telecommand::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Telecommand::CopyFrom(const Telecommand& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Telecommand::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_teleoperation_data()) {
    if (!this->teleoperation_data().IsInitialized()) return false;
  }
  if (has_autonomy_data()) {
    if (!this->autonomy_data().IsInitialized()) return false;
  }
  if (has_steering_mode_data()) {
    if (!this->steering_mode_data().IsInitialized()) return false;
  }
  if (has_define_route_data()) {
    if (!this->define_route_data().IsInitialized()) return false;
  }
  if (has_adjust_pid_data()) {
    if (!this->adjust_pid_data().IsInitialized()) return false;
  }
  if (has_all_wheel_control_data()) {
    if (!this->all_wheel_control_data().IsInitialized()) return false;
  }
  return true;
}

void Telecommand::Swap(Telecommand* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(teleoperation_data_, other->teleoperation_data_);
    std::swap(autonomy_data_, other->autonomy_data_);
    std::swap(steering_mode_data_, other->steering_mode_data_);
    std::swap(define_route_data_, other->define_route_data_);
    std::swap(request_map_data_, other->request_map_data_);
    std::swap(adjust_pid_data_, other->adjust_pid_data_);
    std::swap(all_wheel_control_data_, other->all_wheel_control_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Telecommand::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Telecommand_descriptor_;
  metadata.reflection = Telecommand_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace lunabotics

// @@protoc_insertion_point(global_scope)
