// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Telecommand.proto

#ifndef PROTOBUF_Telecommand_2eproto__INCLUDED
#define PROTOBUF_Telecommand_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "SteeringModeType.pb.h"
#include "Point.pb.h"
#include "AllWheelControl.pb.h"
// @@protoc_insertion_point(includes)

namespace lunabotics {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Telecommand_2eproto();
void protobuf_AssignDesc_Telecommand_2eproto();
void protobuf_ShutdownFile_Telecommand_2eproto();

class Telecommand;
class Telecommand_Teleoperation;
class Telecommand_Autonomy;
class Telecommand_SteeringMode;
class Telecommand_DefineRoute;
class Telecommand_RequestMap;
class Telecommand_AdjustPID;

enum Telecommand_Type {
  Telecommand_Type_TELEOPERATION = 1,
  Telecommand_Type_SET_AUTONOMY = 2,
  Telecommand_Type_STEERING_MODE = 3,
  Telecommand_Type_DEFINE_ROUTE = 4,
  Telecommand_Type_REQUEST_MAP = 5,
  Telecommand_Type_ADJUST_PID = 6,
  Telecommand_Type_ADJUST_WHEELS = 7
};
bool Telecommand_Type_IsValid(int value);
const Telecommand_Type Telecommand_Type_Type_MIN = Telecommand_Type_TELEOPERATION;
const Telecommand_Type Telecommand_Type_Type_MAX = Telecommand_Type_ADJUST_WHEELS;
const int Telecommand_Type_Type_ARRAYSIZE = Telecommand_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Telecommand_Type_descriptor();
inline const ::std::string& Telecommand_Type_Name(Telecommand_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Telecommand_Type_descriptor(), value);
}
inline bool Telecommand_Type_Parse(
    const ::std::string& name, Telecommand_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Telecommand_Type>(
    Telecommand_Type_descriptor(), name, value);
}
// ===================================================================

class Telecommand_Teleoperation : public ::google::protobuf::Message {
 public:
  Telecommand_Teleoperation();
  virtual ~Telecommand_Teleoperation();

  Telecommand_Teleoperation(const Telecommand_Teleoperation& from);

  inline Telecommand_Teleoperation& operator=(const Telecommand_Teleoperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telecommand_Teleoperation& default_instance();

  void Swap(Telecommand_Teleoperation* other);

  // implements Message ----------------------------------------------

  Telecommand_Teleoperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telecommand_Teleoperation& from);
  void MergeFrom(const Telecommand_Teleoperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool forward = 1;
  inline bool has_forward() const;
  inline void clear_forward();
  static const int kForwardFieldNumber = 1;
  inline bool forward() const;
  inline void set_forward(bool value);

  // required bool backward = 2;
  inline bool has_backward() const;
  inline void clear_backward();
  static const int kBackwardFieldNumber = 2;
  inline bool backward() const;
  inline void set_backward(bool value);

  // required bool left = 3;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 3;
  inline bool left() const;
  inline void set_left(bool value);

  // required bool right = 4;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 4;
  inline bool right() const;
  inline void set_right(bool value);

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telecommand.Teleoperation)
 private:
  inline void set_has_forward();
  inline void clear_has_forward();
  inline void set_has_backward();
  inline void clear_has_backward();
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool forward_;
  bool backward_;
  bool left_;
  bool right_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Telecommand_2eproto();
  friend void protobuf_AssignDesc_Telecommand_2eproto();
  friend void protobuf_ShutdownFile_Telecommand_2eproto();

  void InitAsDefaultInstance();
  static Telecommand_Teleoperation* default_instance_;
};
// -------------------------------------------------------------------

class Telecommand_Autonomy : public ::google::protobuf::Message {
 public:
  Telecommand_Autonomy();
  virtual ~Telecommand_Autonomy();

  Telecommand_Autonomy(const Telecommand_Autonomy& from);

  inline Telecommand_Autonomy& operator=(const Telecommand_Autonomy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telecommand_Autonomy& default_instance();

  void Swap(Telecommand_Autonomy* other);

  // implements Message ----------------------------------------------

  Telecommand_Autonomy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telecommand_Autonomy& from);
  void MergeFrom(const Telecommand_Autonomy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool enabled = 1;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telecommand.Autonomy)
 private:
  inline void set_has_enabled();
  inline void clear_has_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Telecommand_2eproto();
  friend void protobuf_AssignDesc_Telecommand_2eproto();
  friend void protobuf_ShutdownFile_Telecommand_2eproto();

  void InitAsDefaultInstance();
  static Telecommand_Autonomy* default_instance_;
};
// -------------------------------------------------------------------

class Telecommand_SteeringMode : public ::google::protobuf::Message {
 public:
  Telecommand_SteeringMode();
  virtual ~Telecommand_SteeringMode();

  Telecommand_SteeringMode(const Telecommand_SteeringMode& from);

  inline Telecommand_SteeringMode& operator=(const Telecommand_SteeringMode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telecommand_SteeringMode& default_instance();

  void Swap(Telecommand_SteeringMode* other);

  // implements Message ----------------------------------------------

  Telecommand_SteeringMode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telecommand_SteeringMode& from);
  void MergeFrom(const Telecommand_SteeringMode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .lunabotics.proto.SteeringModeType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::lunabotics::proto::SteeringModeType type() const;
  inline void set_type(::lunabotics::proto::SteeringModeType value);

  // required float heading_accuracy = 2;
  inline bool has_heading_accuracy() const;
  inline void clear_heading_accuracy();
  static const int kHeadingAccuracyFieldNumber = 2;
  inline float heading_accuracy() const;
  inline void set_heading_accuracy(float value);

  // required float position_accuracy = 3;
  inline bool has_position_accuracy() const;
  inline void clear_position_accuracy();
  static const int kPositionAccuracyFieldNumber = 3;
  inline float position_accuracy() const;
  inline void set_position_accuracy(float value);

  // required float max_linear_velocity = 4;
  inline bool has_max_linear_velocity() const;
  inline void clear_max_linear_velocity();
  static const int kMaxLinearVelocityFieldNumber = 4;
  inline float max_linear_velocity() const;
  inline void set_max_linear_velocity(float value);

  // required int32 bezier_curve_segments = 5;
  inline bool has_bezier_curve_segments() const;
  inline void clear_bezier_curve_segments();
  static const int kBezierCurveSegmentsFieldNumber = 5;
  inline ::google::protobuf::int32 bezier_curve_segments() const;
  inline void set_bezier_curve_segments(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telecommand.SteeringMode)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_heading_accuracy();
  inline void clear_has_heading_accuracy();
  inline void set_has_position_accuracy();
  inline void clear_has_position_accuracy();
  inline void set_has_max_linear_velocity();
  inline void clear_has_max_linear_velocity();
  inline void set_has_bezier_curve_segments();
  inline void clear_has_bezier_curve_segments();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  float heading_accuracy_;
  float position_accuracy_;
  float max_linear_velocity_;
  ::google::protobuf::int32 bezier_curve_segments_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Telecommand_2eproto();
  friend void protobuf_AssignDesc_Telecommand_2eproto();
  friend void protobuf_ShutdownFile_Telecommand_2eproto();

  void InitAsDefaultInstance();
  static Telecommand_SteeringMode* default_instance_;
};
// -------------------------------------------------------------------

class Telecommand_DefineRoute : public ::google::protobuf::Message {
 public:
  Telecommand_DefineRoute();
  virtual ~Telecommand_DefineRoute();

  Telecommand_DefineRoute(const Telecommand_DefineRoute& from);

  inline Telecommand_DefineRoute& operator=(const Telecommand_DefineRoute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telecommand_DefineRoute& default_instance();

  void Swap(Telecommand_DefineRoute* other);

  // implements Message ----------------------------------------------

  Telecommand_DefineRoute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telecommand_DefineRoute& from);
  void MergeFrom(const Telecommand_DefineRoute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lunabotics.proto.Point waypoints = 1;
  inline int waypoints_size() const;
  inline void clear_waypoints();
  static const int kWaypointsFieldNumber = 1;
  inline const ::lunabotics::proto::Point& waypoints(int index) const;
  inline ::lunabotics::proto::Point* mutable_waypoints(int index);
  inline ::lunabotics::proto::Point* add_waypoints();
  inline const ::google::protobuf::RepeatedPtrField< ::lunabotics::proto::Point >&
      waypoints() const;
  inline ::google::protobuf::RepeatedPtrField< ::lunabotics::proto::Point >*
      mutable_waypoints();

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telecommand.DefineRoute)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::lunabotics::proto::Point > waypoints_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Telecommand_2eproto();
  friend void protobuf_AssignDesc_Telecommand_2eproto();
  friend void protobuf_ShutdownFile_Telecommand_2eproto();

  void InitAsDefaultInstance();
  static Telecommand_DefineRoute* default_instance_;
};
// -------------------------------------------------------------------

class Telecommand_RequestMap : public ::google::protobuf::Message {
 public:
  Telecommand_RequestMap();
  virtual ~Telecommand_RequestMap();

  Telecommand_RequestMap(const Telecommand_RequestMap& from);

  inline Telecommand_RequestMap& operator=(const Telecommand_RequestMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telecommand_RequestMap& default_instance();

  void Swap(Telecommand_RequestMap* other);

  // implements Message ----------------------------------------------

  Telecommand_RequestMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telecommand_RequestMap& from);
  void MergeFrom(const Telecommand_RequestMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telecommand.RequestMap)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_Telecommand_2eproto();
  friend void protobuf_AssignDesc_Telecommand_2eproto();
  friend void protobuf_ShutdownFile_Telecommand_2eproto();

  void InitAsDefaultInstance();
  static Telecommand_RequestMap* default_instance_;
};
// -------------------------------------------------------------------

class Telecommand_AdjustPID : public ::google::protobuf::Message {
 public:
  Telecommand_AdjustPID();
  virtual ~Telecommand_AdjustPID();

  Telecommand_AdjustPID(const Telecommand_AdjustPID& from);

  inline Telecommand_AdjustPID& operator=(const Telecommand_AdjustPID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telecommand_AdjustPID& default_instance();

  void Swap(Telecommand_AdjustPID* other);

  // implements Message ----------------------------------------------

  Telecommand_AdjustPID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telecommand_AdjustPID& from);
  void MergeFrom(const Telecommand_AdjustPID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float p = 1;
  inline bool has_p() const;
  inline void clear_p();
  static const int kPFieldNumber = 1;
  inline float p() const;
  inline void set_p(float value);

  // required float i = 2;
  inline bool has_i() const;
  inline void clear_i();
  static const int kIFieldNumber = 2;
  inline float i() const;
  inline void set_i(float value);

  // required float d = 3;
  inline bool has_d() const;
  inline void clear_d();
  static const int kDFieldNumber = 3;
  inline float d() const;
  inline void set_d(float value);

  // required float feedback_min_offset = 4;
  inline bool has_feedback_min_offset() const;
  inline void clear_feedback_min_offset();
  static const int kFeedbackMinOffsetFieldNumber = 4;
  inline float feedback_min_offset() const;
  inline void set_feedback_min_offset(float value);

  // required float feedback_multiplier = 5;
  inline bool has_feedback_multiplier() const;
  inline void clear_feedback_multiplier();
  static const int kFeedbackMultiplierFieldNumber = 5;
  inline float feedback_multiplier() const;
  inline void set_feedback_multiplier(float value);

  // required float feedforward_min_offset = 6;
  inline bool has_feedforward_min_offset() const;
  inline void clear_feedforward_min_offset();
  static const int kFeedforwardMinOffsetFieldNumber = 6;
  inline float feedforward_min_offset() const;
  inline void set_feedforward_min_offset(float value);

  // required float feedforward_fraction = 7;
  inline bool has_feedforward_fraction() const;
  inline void clear_feedforward_fraction();
  static const int kFeedforwardFractionFieldNumber = 7;
  inline float feedforward_fraction() const;
  inline void set_feedforward_fraction(float value);

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telecommand.AdjustPID)
 private:
  inline void set_has_p();
  inline void clear_has_p();
  inline void set_has_i();
  inline void clear_has_i();
  inline void set_has_d();
  inline void clear_has_d();
  inline void set_has_feedback_min_offset();
  inline void clear_has_feedback_min_offset();
  inline void set_has_feedback_multiplier();
  inline void clear_has_feedback_multiplier();
  inline void set_has_feedforward_min_offset();
  inline void clear_has_feedforward_min_offset();
  inline void set_has_feedforward_fraction();
  inline void clear_has_feedforward_fraction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float p_;
  float i_;
  float d_;
  float feedback_min_offset_;
  float feedback_multiplier_;
  float feedforward_min_offset_;
  float feedforward_fraction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Telecommand_2eproto();
  friend void protobuf_AssignDesc_Telecommand_2eproto();
  friend void protobuf_ShutdownFile_Telecommand_2eproto();

  void InitAsDefaultInstance();
  static Telecommand_AdjustPID* default_instance_;
};
// -------------------------------------------------------------------

class Telecommand : public ::google::protobuf::Message {
 public:
  Telecommand();
  virtual ~Telecommand();

  Telecommand(const Telecommand& from);

  inline Telecommand& operator=(const Telecommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telecommand& default_instance();

  void Swap(Telecommand* other);

  // implements Message ----------------------------------------------

  Telecommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telecommand& from);
  void MergeFrom(const Telecommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Telecommand_Teleoperation Teleoperation;
  typedef Telecommand_Autonomy Autonomy;
  typedef Telecommand_SteeringMode SteeringMode;
  typedef Telecommand_DefineRoute DefineRoute;
  typedef Telecommand_RequestMap RequestMap;
  typedef Telecommand_AdjustPID AdjustPID;

  typedef Telecommand_Type Type;
  static const Type TELEOPERATION = Telecommand_Type_TELEOPERATION;
  static const Type SET_AUTONOMY = Telecommand_Type_SET_AUTONOMY;
  static const Type STEERING_MODE = Telecommand_Type_STEERING_MODE;
  static const Type DEFINE_ROUTE = Telecommand_Type_DEFINE_ROUTE;
  static const Type REQUEST_MAP = Telecommand_Type_REQUEST_MAP;
  static const Type ADJUST_PID = Telecommand_Type_ADJUST_PID;
  static const Type ADJUST_WHEELS = Telecommand_Type_ADJUST_WHEELS;
  static inline bool Type_IsValid(int value) {
    return Telecommand_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Telecommand_Type_Type_MIN;
  static const Type Type_MAX =
    Telecommand_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Telecommand_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Telecommand_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Telecommand_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Telecommand_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string reply_port = 1;
  inline bool has_reply_port() const;
  inline void clear_reply_port();
  static const int kReplyPortFieldNumber = 1;
  inline const ::std::string& reply_port() const;
  inline void set_reply_port(const ::std::string& value);
  inline void set_reply_port(const char* value);
  inline void set_reply_port(const char* value, size_t size);
  inline ::std::string* mutable_reply_port();
  inline ::std::string* release_reply_port();
  inline void set_allocated_reply_port(::std::string* reply_port);

  // required .lunabotics.proto.Telecommand.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::lunabotics::proto::Telecommand_Type type() const;
  inline void set_type(::lunabotics::proto::Telecommand_Type value);

  // optional .lunabotics.proto.Telecommand.Teleoperation teleoperation_data = 3;
  inline bool has_teleoperation_data() const;
  inline void clear_teleoperation_data();
  static const int kTeleoperationDataFieldNumber = 3;
  inline const ::lunabotics::proto::Telecommand_Teleoperation& teleoperation_data() const;
  inline ::lunabotics::proto::Telecommand_Teleoperation* mutable_teleoperation_data();
  inline ::lunabotics::proto::Telecommand_Teleoperation* release_teleoperation_data();
  inline void set_allocated_teleoperation_data(::lunabotics::proto::Telecommand_Teleoperation* teleoperation_data);

  // optional .lunabotics.proto.Telecommand.Autonomy autonomy_data = 4;
  inline bool has_autonomy_data() const;
  inline void clear_autonomy_data();
  static const int kAutonomyDataFieldNumber = 4;
  inline const ::lunabotics::proto::Telecommand_Autonomy& autonomy_data() const;
  inline ::lunabotics::proto::Telecommand_Autonomy* mutable_autonomy_data();
  inline ::lunabotics::proto::Telecommand_Autonomy* release_autonomy_data();
  inline void set_allocated_autonomy_data(::lunabotics::proto::Telecommand_Autonomy* autonomy_data);

  // optional .lunabotics.proto.Telecommand.SteeringMode steering_mode_data = 5;
  inline bool has_steering_mode_data() const;
  inline void clear_steering_mode_data();
  static const int kSteeringModeDataFieldNumber = 5;
  inline const ::lunabotics::proto::Telecommand_SteeringMode& steering_mode_data() const;
  inline ::lunabotics::proto::Telecommand_SteeringMode* mutable_steering_mode_data();
  inline ::lunabotics::proto::Telecommand_SteeringMode* release_steering_mode_data();
  inline void set_allocated_steering_mode_data(::lunabotics::proto::Telecommand_SteeringMode* steering_mode_data);

  // optional .lunabotics.proto.Telecommand.DefineRoute define_route_data = 6;
  inline bool has_define_route_data() const;
  inline void clear_define_route_data();
  static const int kDefineRouteDataFieldNumber = 6;
  inline const ::lunabotics::proto::Telecommand_DefineRoute& define_route_data() const;
  inline ::lunabotics::proto::Telecommand_DefineRoute* mutable_define_route_data();
  inline ::lunabotics::proto::Telecommand_DefineRoute* release_define_route_data();
  inline void set_allocated_define_route_data(::lunabotics::proto::Telecommand_DefineRoute* define_route_data);

  // optional .lunabotics.proto.Telecommand.RequestMap request_map_data = 7;
  inline bool has_request_map_data() const;
  inline void clear_request_map_data();
  static const int kRequestMapDataFieldNumber = 7;
  inline const ::lunabotics::proto::Telecommand_RequestMap& request_map_data() const;
  inline ::lunabotics::proto::Telecommand_RequestMap* mutable_request_map_data();
  inline ::lunabotics::proto::Telecommand_RequestMap* release_request_map_data();
  inline void set_allocated_request_map_data(::lunabotics::proto::Telecommand_RequestMap* request_map_data);

  // optional .lunabotics.proto.Telecommand.AdjustPID adjust_pid_data = 8;
  inline bool has_adjust_pid_data() const;
  inline void clear_adjust_pid_data();
  static const int kAdjustPidDataFieldNumber = 8;
  inline const ::lunabotics::proto::Telecommand_AdjustPID& adjust_pid_data() const;
  inline ::lunabotics::proto::Telecommand_AdjustPID* mutable_adjust_pid_data();
  inline ::lunabotics::proto::Telecommand_AdjustPID* release_adjust_pid_data();
  inline void set_allocated_adjust_pid_data(::lunabotics::proto::Telecommand_AdjustPID* adjust_pid_data);

  // optional .lunabotics.proto.AllWheelControl all_wheel_control_data = 9;
  inline bool has_all_wheel_control_data() const;
  inline void clear_all_wheel_control_data();
  static const int kAllWheelControlDataFieldNumber = 9;
  inline const ::lunabotics::proto::AllWheelControl& all_wheel_control_data() const;
  inline ::lunabotics::proto::AllWheelControl* mutable_all_wheel_control_data();
  inline ::lunabotics::proto::AllWheelControl* release_all_wheel_control_data();
  inline void set_allocated_all_wheel_control_data(::lunabotics::proto::AllWheelControl* all_wheel_control_data);

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telecommand)
 private:
  inline void set_has_reply_port();
  inline void clear_has_reply_port();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_teleoperation_data();
  inline void clear_has_teleoperation_data();
  inline void set_has_autonomy_data();
  inline void clear_has_autonomy_data();
  inline void set_has_steering_mode_data();
  inline void clear_has_steering_mode_data();
  inline void set_has_define_route_data();
  inline void clear_has_define_route_data();
  inline void set_has_request_map_data();
  inline void clear_has_request_map_data();
  inline void set_has_adjust_pid_data();
  inline void clear_has_adjust_pid_data();
  inline void set_has_all_wheel_control_data();
  inline void clear_has_all_wheel_control_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* reply_port_;
  ::lunabotics::proto::Telecommand_Teleoperation* teleoperation_data_;
  ::lunabotics::proto::Telecommand_Autonomy* autonomy_data_;
  ::lunabotics::proto::Telecommand_SteeringMode* steering_mode_data_;
  ::lunabotics::proto::Telecommand_DefineRoute* define_route_data_;
  ::lunabotics::proto::Telecommand_RequestMap* request_map_data_;
  ::lunabotics::proto::Telecommand_AdjustPID* adjust_pid_data_;
  ::lunabotics::proto::AllWheelControl* all_wheel_control_data_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_Telecommand_2eproto();
  friend void protobuf_AssignDesc_Telecommand_2eproto();
  friend void protobuf_ShutdownFile_Telecommand_2eproto();

  void InitAsDefaultInstance();
  static Telecommand* default_instance_;
};
// ===================================================================


// ===================================================================

// Telecommand_Teleoperation

// required bool forward = 1;
inline bool Telecommand_Teleoperation::has_forward() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telecommand_Teleoperation::set_has_forward() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telecommand_Teleoperation::clear_has_forward() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telecommand_Teleoperation::clear_forward() {
  forward_ = false;
  clear_has_forward();
}
inline bool Telecommand_Teleoperation::forward() const {
  return forward_;
}
inline void Telecommand_Teleoperation::set_forward(bool value) {
  set_has_forward();
  forward_ = value;
}

// required bool backward = 2;
inline bool Telecommand_Teleoperation::has_backward() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Telecommand_Teleoperation::set_has_backward() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Telecommand_Teleoperation::clear_has_backward() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Telecommand_Teleoperation::clear_backward() {
  backward_ = false;
  clear_has_backward();
}
inline bool Telecommand_Teleoperation::backward() const {
  return backward_;
}
inline void Telecommand_Teleoperation::set_backward(bool value) {
  set_has_backward();
  backward_ = value;
}

// required bool left = 3;
inline bool Telecommand_Teleoperation::has_left() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Telecommand_Teleoperation::set_has_left() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Telecommand_Teleoperation::clear_has_left() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Telecommand_Teleoperation::clear_left() {
  left_ = false;
  clear_has_left();
}
inline bool Telecommand_Teleoperation::left() const {
  return left_;
}
inline void Telecommand_Teleoperation::set_left(bool value) {
  set_has_left();
  left_ = value;
}

// required bool right = 4;
inline bool Telecommand_Teleoperation::has_right() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Telecommand_Teleoperation::set_has_right() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Telecommand_Teleoperation::clear_has_right() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Telecommand_Teleoperation::clear_right() {
  right_ = false;
  clear_has_right();
}
inline bool Telecommand_Teleoperation::right() const {
  return right_;
}
inline void Telecommand_Teleoperation::set_right(bool value) {
  set_has_right();
  right_ = value;
}

// -------------------------------------------------------------------

// Telecommand_Autonomy

// required bool enabled = 1;
inline bool Telecommand_Autonomy::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telecommand_Autonomy::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telecommand_Autonomy::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telecommand_Autonomy::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool Telecommand_Autonomy::enabled() const {
  return enabled_;
}
inline void Telecommand_Autonomy::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// -------------------------------------------------------------------

// Telecommand_SteeringMode

// required .lunabotics.proto.SteeringModeType type = 1;
inline bool Telecommand_SteeringMode::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telecommand_SteeringMode::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telecommand_SteeringMode::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telecommand_SteeringMode::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::lunabotics::proto::SteeringModeType Telecommand_SteeringMode::type() const {
  return static_cast< ::lunabotics::proto::SteeringModeType >(type_);
}
inline void Telecommand_SteeringMode::set_type(::lunabotics::proto::SteeringModeType value) {
  assert(::lunabotics::proto::SteeringModeType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required float heading_accuracy = 2;
inline bool Telecommand_SteeringMode::has_heading_accuracy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Telecommand_SteeringMode::set_has_heading_accuracy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Telecommand_SteeringMode::clear_has_heading_accuracy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Telecommand_SteeringMode::clear_heading_accuracy() {
  heading_accuracy_ = 0;
  clear_has_heading_accuracy();
}
inline float Telecommand_SteeringMode::heading_accuracy() const {
  return heading_accuracy_;
}
inline void Telecommand_SteeringMode::set_heading_accuracy(float value) {
  set_has_heading_accuracy();
  heading_accuracy_ = value;
}

// required float position_accuracy = 3;
inline bool Telecommand_SteeringMode::has_position_accuracy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Telecommand_SteeringMode::set_has_position_accuracy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Telecommand_SteeringMode::clear_has_position_accuracy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Telecommand_SteeringMode::clear_position_accuracy() {
  position_accuracy_ = 0;
  clear_has_position_accuracy();
}
inline float Telecommand_SteeringMode::position_accuracy() const {
  return position_accuracy_;
}
inline void Telecommand_SteeringMode::set_position_accuracy(float value) {
  set_has_position_accuracy();
  position_accuracy_ = value;
}

// required float max_linear_velocity = 4;
inline bool Telecommand_SteeringMode::has_max_linear_velocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Telecommand_SteeringMode::set_has_max_linear_velocity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Telecommand_SteeringMode::clear_has_max_linear_velocity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Telecommand_SteeringMode::clear_max_linear_velocity() {
  max_linear_velocity_ = 0;
  clear_has_max_linear_velocity();
}
inline float Telecommand_SteeringMode::max_linear_velocity() const {
  return max_linear_velocity_;
}
inline void Telecommand_SteeringMode::set_max_linear_velocity(float value) {
  set_has_max_linear_velocity();
  max_linear_velocity_ = value;
}

// required int32 bezier_curve_segments = 5;
inline bool Telecommand_SteeringMode::has_bezier_curve_segments() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Telecommand_SteeringMode::set_has_bezier_curve_segments() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Telecommand_SteeringMode::clear_has_bezier_curve_segments() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Telecommand_SteeringMode::clear_bezier_curve_segments() {
  bezier_curve_segments_ = 0;
  clear_has_bezier_curve_segments();
}
inline ::google::protobuf::int32 Telecommand_SteeringMode::bezier_curve_segments() const {
  return bezier_curve_segments_;
}
inline void Telecommand_SteeringMode::set_bezier_curve_segments(::google::protobuf::int32 value) {
  set_has_bezier_curve_segments();
  bezier_curve_segments_ = value;
}

// -------------------------------------------------------------------

// Telecommand_DefineRoute

// repeated .lunabotics.proto.Point waypoints = 1;
inline int Telecommand_DefineRoute::waypoints_size() const {
  return waypoints_.size();
}
inline void Telecommand_DefineRoute::clear_waypoints() {
  waypoints_.Clear();
}
inline const ::lunabotics::proto::Point& Telecommand_DefineRoute::waypoints(int index) const {
  return waypoints_.Get(index);
}
inline ::lunabotics::proto::Point* Telecommand_DefineRoute::mutable_waypoints(int index) {
  return waypoints_.Mutable(index);
}
inline ::lunabotics::proto::Point* Telecommand_DefineRoute::add_waypoints() {
  return waypoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lunabotics::proto::Point >&
Telecommand_DefineRoute::waypoints() const {
  return waypoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::lunabotics::proto::Point >*
Telecommand_DefineRoute::mutable_waypoints() {
  return &waypoints_;
}

// -------------------------------------------------------------------

// Telecommand_RequestMap

// -------------------------------------------------------------------

// Telecommand_AdjustPID

// required float p = 1;
inline bool Telecommand_AdjustPID::has_p() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telecommand_AdjustPID::set_has_p() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telecommand_AdjustPID::clear_has_p() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telecommand_AdjustPID::clear_p() {
  p_ = 0;
  clear_has_p();
}
inline float Telecommand_AdjustPID::p() const {
  return p_;
}
inline void Telecommand_AdjustPID::set_p(float value) {
  set_has_p();
  p_ = value;
}

// required float i = 2;
inline bool Telecommand_AdjustPID::has_i() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Telecommand_AdjustPID::set_has_i() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Telecommand_AdjustPID::clear_has_i() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Telecommand_AdjustPID::clear_i() {
  i_ = 0;
  clear_has_i();
}
inline float Telecommand_AdjustPID::i() const {
  return i_;
}
inline void Telecommand_AdjustPID::set_i(float value) {
  set_has_i();
  i_ = value;
}

// required float d = 3;
inline bool Telecommand_AdjustPID::has_d() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Telecommand_AdjustPID::set_has_d() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Telecommand_AdjustPID::clear_has_d() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Telecommand_AdjustPID::clear_d() {
  d_ = 0;
  clear_has_d();
}
inline float Telecommand_AdjustPID::d() const {
  return d_;
}
inline void Telecommand_AdjustPID::set_d(float value) {
  set_has_d();
  d_ = value;
}

// required float feedback_min_offset = 4;
inline bool Telecommand_AdjustPID::has_feedback_min_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Telecommand_AdjustPID::set_has_feedback_min_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Telecommand_AdjustPID::clear_has_feedback_min_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Telecommand_AdjustPID::clear_feedback_min_offset() {
  feedback_min_offset_ = 0;
  clear_has_feedback_min_offset();
}
inline float Telecommand_AdjustPID::feedback_min_offset() const {
  return feedback_min_offset_;
}
inline void Telecommand_AdjustPID::set_feedback_min_offset(float value) {
  set_has_feedback_min_offset();
  feedback_min_offset_ = value;
}

// required float feedback_multiplier = 5;
inline bool Telecommand_AdjustPID::has_feedback_multiplier() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Telecommand_AdjustPID::set_has_feedback_multiplier() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Telecommand_AdjustPID::clear_has_feedback_multiplier() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Telecommand_AdjustPID::clear_feedback_multiplier() {
  feedback_multiplier_ = 0;
  clear_has_feedback_multiplier();
}
inline float Telecommand_AdjustPID::feedback_multiplier() const {
  return feedback_multiplier_;
}
inline void Telecommand_AdjustPID::set_feedback_multiplier(float value) {
  set_has_feedback_multiplier();
  feedback_multiplier_ = value;
}

// required float feedforward_min_offset = 6;
inline bool Telecommand_AdjustPID::has_feedforward_min_offset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Telecommand_AdjustPID::set_has_feedforward_min_offset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Telecommand_AdjustPID::clear_has_feedforward_min_offset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Telecommand_AdjustPID::clear_feedforward_min_offset() {
  feedforward_min_offset_ = 0;
  clear_has_feedforward_min_offset();
}
inline float Telecommand_AdjustPID::feedforward_min_offset() const {
  return feedforward_min_offset_;
}
inline void Telecommand_AdjustPID::set_feedforward_min_offset(float value) {
  set_has_feedforward_min_offset();
  feedforward_min_offset_ = value;
}

// required float feedforward_fraction = 7;
inline bool Telecommand_AdjustPID::has_feedforward_fraction() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Telecommand_AdjustPID::set_has_feedforward_fraction() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Telecommand_AdjustPID::clear_has_feedforward_fraction() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Telecommand_AdjustPID::clear_feedforward_fraction() {
  feedforward_fraction_ = 0;
  clear_has_feedforward_fraction();
}
inline float Telecommand_AdjustPID::feedforward_fraction() const {
  return feedforward_fraction_;
}
inline void Telecommand_AdjustPID::set_feedforward_fraction(float value) {
  set_has_feedforward_fraction();
  feedforward_fraction_ = value;
}

// -------------------------------------------------------------------

// Telecommand

// required string reply_port = 1;
inline bool Telecommand::has_reply_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telecommand::set_has_reply_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telecommand::clear_has_reply_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telecommand::clear_reply_port() {
  if (reply_port_ != &::google::protobuf::internal::kEmptyString) {
    reply_port_->clear();
  }
  clear_has_reply_port();
}
inline const ::std::string& Telecommand::reply_port() const {
  return *reply_port_;
}
inline void Telecommand::set_reply_port(const ::std::string& value) {
  set_has_reply_port();
  if (reply_port_ == &::google::protobuf::internal::kEmptyString) {
    reply_port_ = new ::std::string;
  }
  reply_port_->assign(value);
}
inline void Telecommand::set_reply_port(const char* value) {
  set_has_reply_port();
  if (reply_port_ == &::google::protobuf::internal::kEmptyString) {
    reply_port_ = new ::std::string;
  }
  reply_port_->assign(value);
}
inline void Telecommand::set_reply_port(const char* value, size_t size) {
  set_has_reply_port();
  if (reply_port_ == &::google::protobuf::internal::kEmptyString) {
    reply_port_ = new ::std::string;
  }
  reply_port_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Telecommand::mutable_reply_port() {
  set_has_reply_port();
  if (reply_port_ == &::google::protobuf::internal::kEmptyString) {
    reply_port_ = new ::std::string;
  }
  return reply_port_;
}
inline ::std::string* Telecommand::release_reply_port() {
  clear_has_reply_port();
  if (reply_port_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reply_port_;
    reply_port_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Telecommand::set_allocated_reply_port(::std::string* reply_port) {
  if (reply_port_ != &::google::protobuf::internal::kEmptyString) {
    delete reply_port_;
  }
  if (reply_port) {
    set_has_reply_port();
    reply_port_ = reply_port;
  } else {
    clear_has_reply_port();
    reply_port_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .lunabotics.proto.Telecommand.Type type = 2;
inline bool Telecommand::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Telecommand::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Telecommand::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Telecommand::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::lunabotics::proto::Telecommand_Type Telecommand::type() const {
  return static_cast< ::lunabotics::proto::Telecommand_Type >(type_);
}
inline void Telecommand::set_type(::lunabotics::proto::Telecommand_Type value) {
  assert(::lunabotics::proto::Telecommand_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .lunabotics.proto.Telecommand.Teleoperation teleoperation_data = 3;
inline bool Telecommand::has_teleoperation_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Telecommand::set_has_teleoperation_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Telecommand::clear_has_teleoperation_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Telecommand::clear_teleoperation_data() {
  if (teleoperation_data_ != NULL) teleoperation_data_->::lunabotics::proto::Telecommand_Teleoperation::Clear();
  clear_has_teleoperation_data();
}
inline const ::lunabotics::proto::Telecommand_Teleoperation& Telecommand::teleoperation_data() const {
  return teleoperation_data_ != NULL ? *teleoperation_data_ : *default_instance_->teleoperation_data_;
}
inline ::lunabotics::proto::Telecommand_Teleoperation* Telecommand::mutable_teleoperation_data() {
  set_has_teleoperation_data();
  if (teleoperation_data_ == NULL) teleoperation_data_ = new ::lunabotics::proto::Telecommand_Teleoperation;
  return teleoperation_data_;
}
inline ::lunabotics::proto::Telecommand_Teleoperation* Telecommand::release_teleoperation_data() {
  clear_has_teleoperation_data();
  ::lunabotics::proto::Telecommand_Teleoperation* temp = teleoperation_data_;
  teleoperation_data_ = NULL;
  return temp;
}
inline void Telecommand::set_allocated_teleoperation_data(::lunabotics::proto::Telecommand_Teleoperation* teleoperation_data) {
  delete teleoperation_data_;
  teleoperation_data_ = teleoperation_data;
  if (teleoperation_data) {
    set_has_teleoperation_data();
  } else {
    clear_has_teleoperation_data();
  }
}

// optional .lunabotics.proto.Telecommand.Autonomy autonomy_data = 4;
inline bool Telecommand::has_autonomy_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Telecommand::set_has_autonomy_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Telecommand::clear_has_autonomy_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Telecommand::clear_autonomy_data() {
  if (autonomy_data_ != NULL) autonomy_data_->::lunabotics::proto::Telecommand_Autonomy::Clear();
  clear_has_autonomy_data();
}
inline const ::lunabotics::proto::Telecommand_Autonomy& Telecommand::autonomy_data() const {
  return autonomy_data_ != NULL ? *autonomy_data_ : *default_instance_->autonomy_data_;
}
inline ::lunabotics::proto::Telecommand_Autonomy* Telecommand::mutable_autonomy_data() {
  set_has_autonomy_data();
  if (autonomy_data_ == NULL) autonomy_data_ = new ::lunabotics::proto::Telecommand_Autonomy;
  return autonomy_data_;
}
inline ::lunabotics::proto::Telecommand_Autonomy* Telecommand::release_autonomy_data() {
  clear_has_autonomy_data();
  ::lunabotics::proto::Telecommand_Autonomy* temp = autonomy_data_;
  autonomy_data_ = NULL;
  return temp;
}
inline void Telecommand::set_allocated_autonomy_data(::lunabotics::proto::Telecommand_Autonomy* autonomy_data) {
  delete autonomy_data_;
  autonomy_data_ = autonomy_data;
  if (autonomy_data) {
    set_has_autonomy_data();
  } else {
    clear_has_autonomy_data();
  }
}

// optional .lunabotics.proto.Telecommand.SteeringMode steering_mode_data = 5;
inline bool Telecommand::has_steering_mode_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Telecommand::set_has_steering_mode_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Telecommand::clear_has_steering_mode_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Telecommand::clear_steering_mode_data() {
  if (steering_mode_data_ != NULL) steering_mode_data_->::lunabotics::proto::Telecommand_SteeringMode::Clear();
  clear_has_steering_mode_data();
}
inline const ::lunabotics::proto::Telecommand_SteeringMode& Telecommand::steering_mode_data() const {
  return steering_mode_data_ != NULL ? *steering_mode_data_ : *default_instance_->steering_mode_data_;
}
inline ::lunabotics::proto::Telecommand_SteeringMode* Telecommand::mutable_steering_mode_data() {
  set_has_steering_mode_data();
  if (steering_mode_data_ == NULL) steering_mode_data_ = new ::lunabotics::proto::Telecommand_SteeringMode;
  return steering_mode_data_;
}
inline ::lunabotics::proto::Telecommand_SteeringMode* Telecommand::release_steering_mode_data() {
  clear_has_steering_mode_data();
  ::lunabotics::proto::Telecommand_SteeringMode* temp = steering_mode_data_;
  steering_mode_data_ = NULL;
  return temp;
}
inline void Telecommand::set_allocated_steering_mode_data(::lunabotics::proto::Telecommand_SteeringMode* steering_mode_data) {
  delete steering_mode_data_;
  steering_mode_data_ = steering_mode_data;
  if (steering_mode_data) {
    set_has_steering_mode_data();
  } else {
    clear_has_steering_mode_data();
  }
}

// optional .lunabotics.proto.Telecommand.DefineRoute define_route_data = 6;
inline bool Telecommand::has_define_route_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Telecommand::set_has_define_route_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Telecommand::clear_has_define_route_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Telecommand::clear_define_route_data() {
  if (define_route_data_ != NULL) define_route_data_->::lunabotics::proto::Telecommand_DefineRoute::Clear();
  clear_has_define_route_data();
}
inline const ::lunabotics::proto::Telecommand_DefineRoute& Telecommand::define_route_data() const {
  return define_route_data_ != NULL ? *define_route_data_ : *default_instance_->define_route_data_;
}
inline ::lunabotics::proto::Telecommand_DefineRoute* Telecommand::mutable_define_route_data() {
  set_has_define_route_data();
  if (define_route_data_ == NULL) define_route_data_ = new ::lunabotics::proto::Telecommand_DefineRoute;
  return define_route_data_;
}
inline ::lunabotics::proto::Telecommand_DefineRoute* Telecommand::release_define_route_data() {
  clear_has_define_route_data();
  ::lunabotics::proto::Telecommand_DefineRoute* temp = define_route_data_;
  define_route_data_ = NULL;
  return temp;
}
inline void Telecommand::set_allocated_define_route_data(::lunabotics::proto::Telecommand_DefineRoute* define_route_data) {
  delete define_route_data_;
  define_route_data_ = define_route_data;
  if (define_route_data) {
    set_has_define_route_data();
  } else {
    clear_has_define_route_data();
  }
}

// optional .lunabotics.proto.Telecommand.RequestMap request_map_data = 7;
inline bool Telecommand::has_request_map_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Telecommand::set_has_request_map_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Telecommand::clear_has_request_map_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Telecommand::clear_request_map_data() {
  if (request_map_data_ != NULL) request_map_data_->::lunabotics::proto::Telecommand_RequestMap::Clear();
  clear_has_request_map_data();
}
inline const ::lunabotics::proto::Telecommand_RequestMap& Telecommand::request_map_data() const {
  return request_map_data_ != NULL ? *request_map_data_ : *default_instance_->request_map_data_;
}
inline ::lunabotics::proto::Telecommand_RequestMap* Telecommand::mutable_request_map_data() {
  set_has_request_map_data();
  if (request_map_data_ == NULL) request_map_data_ = new ::lunabotics::proto::Telecommand_RequestMap;
  return request_map_data_;
}
inline ::lunabotics::proto::Telecommand_RequestMap* Telecommand::release_request_map_data() {
  clear_has_request_map_data();
  ::lunabotics::proto::Telecommand_RequestMap* temp = request_map_data_;
  request_map_data_ = NULL;
  return temp;
}
inline void Telecommand::set_allocated_request_map_data(::lunabotics::proto::Telecommand_RequestMap* request_map_data) {
  delete request_map_data_;
  request_map_data_ = request_map_data;
  if (request_map_data) {
    set_has_request_map_data();
  } else {
    clear_has_request_map_data();
  }
}

// optional .lunabotics.proto.Telecommand.AdjustPID adjust_pid_data = 8;
inline bool Telecommand::has_adjust_pid_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Telecommand::set_has_adjust_pid_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Telecommand::clear_has_adjust_pid_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Telecommand::clear_adjust_pid_data() {
  if (adjust_pid_data_ != NULL) adjust_pid_data_->::lunabotics::proto::Telecommand_AdjustPID::Clear();
  clear_has_adjust_pid_data();
}
inline const ::lunabotics::proto::Telecommand_AdjustPID& Telecommand::adjust_pid_data() const {
  return adjust_pid_data_ != NULL ? *adjust_pid_data_ : *default_instance_->adjust_pid_data_;
}
inline ::lunabotics::proto::Telecommand_AdjustPID* Telecommand::mutable_adjust_pid_data() {
  set_has_adjust_pid_data();
  if (adjust_pid_data_ == NULL) adjust_pid_data_ = new ::lunabotics::proto::Telecommand_AdjustPID;
  return adjust_pid_data_;
}
inline ::lunabotics::proto::Telecommand_AdjustPID* Telecommand::release_adjust_pid_data() {
  clear_has_adjust_pid_data();
  ::lunabotics::proto::Telecommand_AdjustPID* temp = adjust_pid_data_;
  adjust_pid_data_ = NULL;
  return temp;
}
inline void Telecommand::set_allocated_adjust_pid_data(::lunabotics::proto::Telecommand_AdjustPID* adjust_pid_data) {
  delete adjust_pid_data_;
  adjust_pid_data_ = adjust_pid_data;
  if (adjust_pid_data) {
    set_has_adjust_pid_data();
  } else {
    clear_has_adjust_pid_data();
  }
}

// optional .lunabotics.proto.AllWheelControl all_wheel_control_data = 9;
inline bool Telecommand::has_all_wheel_control_data() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Telecommand::set_has_all_wheel_control_data() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Telecommand::clear_has_all_wheel_control_data() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Telecommand::clear_all_wheel_control_data() {
  if (all_wheel_control_data_ != NULL) all_wheel_control_data_->::lunabotics::proto::AllWheelControl::Clear();
  clear_has_all_wheel_control_data();
}
inline const ::lunabotics::proto::AllWheelControl& Telecommand::all_wheel_control_data() const {
  return all_wheel_control_data_ != NULL ? *all_wheel_control_data_ : *default_instance_->all_wheel_control_data_;
}
inline ::lunabotics::proto::AllWheelControl* Telecommand::mutable_all_wheel_control_data() {
  set_has_all_wheel_control_data();
  if (all_wheel_control_data_ == NULL) all_wheel_control_data_ = new ::lunabotics::proto::AllWheelControl;
  return all_wheel_control_data_;
}
inline ::lunabotics::proto::AllWheelControl* Telecommand::release_all_wheel_control_data() {
  clear_has_all_wheel_control_data();
  ::lunabotics::proto::AllWheelControl* temp = all_wheel_control_data_;
  all_wheel_control_data_ = NULL;
  return temp;
}
inline void Telecommand::set_allocated_all_wheel_control_data(::lunabotics::proto::AllWheelControl* all_wheel_control_data) {
  delete all_wheel_control_data_;
  all_wheel_control_data_ = all_wheel_control_data;
  if (all_wheel_control_data) {
    set_has_all_wheel_control_data();
  } else {
    clear_has_all_wheel_control_data();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace lunabotics

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lunabotics::proto::Telecommand_Type>() {
  return ::lunabotics::proto::Telecommand_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Telecommand_2eproto__INCLUDED
