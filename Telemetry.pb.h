// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Telemetry.proto

#ifndef PROTOBUF_Telemetry_2eproto__INCLUDED
#define PROTOBUF_Telemetry_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "SteeringModeType.pb.h"
#include "Point.pb.h"
#include "Twist.pb.h"
#include "AllWheelState.pb.h"
// @@protoc_insertion_point(includes)

namespace lunabotics {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Telemetry_2eproto();
void protobuf_AssignDesc_Telemetry_2eproto();
void protobuf_ShutdownFile_Telemetry_2eproto();

class Telemetry;
class Telemetry_State;
class Telemetry_State_AckermannTelemetry;
class Telemetry_State_PointTurnTelemetry;
class Telemetry_World;
class Telemetry_Path;
class Telemetry_LaserScan;
class Telemetry_Geometry;

enum Telemetry_PointTurnState {
  Telemetry_PointTurnState_STOPPED = 1,
  Telemetry_PointTurnState_DRIVING = 2,
  Telemetry_PointTurnState_TURNING = 3
};
bool Telemetry_PointTurnState_IsValid(int value);
const Telemetry_PointTurnState Telemetry_PointTurnState_PointTurnState_MIN = Telemetry_PointTurnState_STOPPED;
const Telemetry_PointTurnState Telemetry_PointTurnState_PointTurnState_MAX = Telemetry_PointTurnState_TURNING;
const int Telemetry_PointTurnState_PointTurnState_ARRAYSIZE = Telemetry_PointTurnState_PointTurnState_MAX + 1;

const ::google::protobuf::EnumDescriptor* Telemetry_PointTurnState_descriptor();
inline const ::std::string& Telemetry_PointTurnState_Name(Telemetry_PointTurnState value) {
  return ::google::protobuf::internal::NameOfEnum(
    Telemetry_PointTurnState_descriptor(), value);
}
inline bool Telemetry_PointTurnState_Parse(
    const ::std::string& name, Telemetry_PointTurnState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Telemetry_PointTurnState>(
    Telemetry_PointTurnState_descriptor(), name, value);
}
// ===================================================================

class Telemetry_State_AckermannTelemetry : public ::google::protobuf::Message {
 public:
  Telemetry_State_AckermannTelemetry();
  virtual ~Telemetry_State_AckermannTelemetry();

  Telemetry_State_AckermannTelemetry(const Telemetry_State_AckermannTelemetry& from);

  inline Telemetry_State_AckermannTelemetry& operator=(const Telemetry_State_AckermannTelemetry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telemetry_State_AckermannTelemetry& default_instance();

  void Swap(Telemetry_State_AckermannTelemetry* other);

  // implements Message ----------------------------------------------

  Telemetry_State_AckermannTelemetry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telemetry_State_AckermannTelemetry& from);
  void MergeFrom(const Telemetry_State_AckermannTelemetry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float pid_error = 1;
  inline bool has_pid_error() const;
  inline void clear_pid_error();
  static const int kPidErrorFieldNumber = 1;
  inline float pid_error() const;
  inline void set_pid_error(float value);

  // required .lunabotics.proto.Point closest_trajectory_point = 2;
  inline bool has_closest_trajectory_point() const;
  inline void clear_closest_trajectory_point();
  static const int kClosestTrajectoryPointFieldNumber = 2;
  inline const ::lunabotics::proto::Point& closest_trajectory_point() const;
  inline ::lunabotics::proto::Point* mutable_closest_trajectory_point();
  inline ::lunabotics::proto::Point* release_closest_trajectory_point();
  inline void set_allocated_closest_trajectory_point(::lunabotics::proto::Point* closest_trajectory_point);

  // required .lunabotics.proto.Point velocity_vector_point = 3;
  inline bool has_velocity_vector_point() const;
  inline void clear_velocity_vector_point();
  static const int kVelocityVectorPointFieldNumber = 3;
  inline const ::lunabotics::proto::Point& velocity_vector_point() const;
  inline ::lunabotics::proto::Point* mutable_velocity_vector_point();
  inline ::lunabotics::proto::Point* release_velocity_vector_point();
  inline void set_allocated_velocity_vector_point(::lunabotics::proto::Point* velocity_vector_point);

  // required .lunabotics.proto.Point closest_trajectory_local_point = 4;
  inline bool has_closest_trajectory_local_point() const;
  inline void clear_closest_trajectory_local_point();
  static const int kClosestTrajectoryLocalPointFieldNumber = 4;
  inline const ::lunabotics::proto::Point& closest_trajectory_local_point() const;
  inline ::lunabotics::proto::Point* mutable_closest_trajectory_local_point();
  inline ::lunabotics::proto::Point* release_closest_trajectory_local_point();
  inline void set_allocated_closest_trajectory_local_point(::lunabotics::proto::Point* closest_trajectory_local_point);

  // required .lunabotics.proto.Point velocity_vector_local_point = 5;
  inline bool has_velocity_vector_local_point() const;
  inline void clear_velocity_vector_local_point();
  static const int kVelocityVectorLocalPointFieldNumber = 5;
  inline const ::lunabotics::proto::Point& velocity_vector_local_point() const;
  inline ::lunabotics::proto::Point* mutable_velocity_vector_local_point();
  inline ::lunabotics::proto::Point* release_velocity_vector_local_point();
  inline void set_allocated_velocity_vector_local_point(::lunabotics::proto::Point* velocity_vector_local_point);

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telemetry.State.AckermannTelemetry)
 private:
  inline void set_has_pid_error();
  inline void clear_has_pid_error();
  inline void set_has_closest_trajectory_point();
  inline void clear_has_closest_trajectory_point();
  inline void set_has_velocity_vector_point();
  inline void clear_has_velocity_vector_point();
  inline void set_has_closest_trajectory_local_point();
  inline void clear_has_closest_trajectory_local_point();
  inline void set_has_velocity_vector_local_point();
  inline void clear_has_velocity_vector_local_point();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::lunabotics::proto::Point* closest_trajectory_point_;
  ::lunabotics::proto::Point* velocity_vector_point_;
  ::lunabotics::proto::Point* closest_trajectory_local_point_;
  ::lunabotics::proto::Point* velocity_vector_local_point_;
  float pid_error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Telemetry_2eproto();
  friend void protobuf_AssignDesc_Telemetry_2eproto();
  friend void protobuf_ShutdownFile_Telemetry_2eproto();

  void InitAsDefaultInstance();
  static Telemetry_State_AckermannTelemetry* default_instance_;
};
// -------------------------------------------------------------------

class Telemetry_State_PointTurnTelemetry : public ::google::protobuf::Message {
 public:
  Telemetry_State_PointTurnTelemetry();
  virtual ~Telemetry_State_PointTurnTelemetry();

  Telemetry_State_PointTurnTelemetry(const Telemetry_State_PointTurnTelemetry& from);

  inline Telemetry_State_PointTurnTelemetry& operator=(const Telemetry_State_PointTurnTelemetry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telemetry_State_PointTurnTelemetry& default_instance();

  void Swap(Telemetry_State_PointTurnTelemetry* other);

  // implements Message ----------------------------------------------

  Telemetry_State_PointTurnTelemetry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telemetry_State_PointTurnTelemetry& from);
  void MergeFrom(const Telemetry_State_PointTurnTelemetry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .lunabotics.proto.Telemetry.PointTurnState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::lunabotics::proto::Telemetry_PointTurnState state() const;
  inline void set_state(::lunabotics::proto::Telemetry_PointTurnState value);

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telemetry.State.PointTurnTelemetry)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Telemetry_2eproto();
  friend void protobuf_AssignDesc_Telemetry_2eproto();
  friend void protobuf_ShutdownFile_Telemetry_2eproto();

  void InitAsDefaultInstance();
  static Telemetry_State_PointTurnTelemetry* default_instance_;
};
// -------------------------------------------------------------------

class Telemetry_State : public ::google::protobuf::Message {
 public:
  Telemetry_State();
  virtual ~Telemetry_State();

  Telemetry_State(const Telemetry_State& from);

  inline Telemetry_State& operator=(const Telemetry_State& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telemetry_State& default_instance();

  void Swap(Telemetry_State* other);

  // implements Message ----------------------------------------------

  Telemetry_State* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telemetry_State& from);
  void MergeFrom(const Telemetry_State& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Telemetry_State_AckermannTelemetry AckermannTelemetry;
  typedef Telemetry_State_PointTurnTelemetry PointTurnTelemetry;

  // accessors -------------------------------------------------------

  // required .lunabotics.proto.Point position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::lunabotics::proto::Point& position() const;
  inline ::lunabotics::proto::Point* mutable_position();
  inline ::lunabotics::proto::Point* release_position();
  inline void set_allocated_position(::lunabotics::proto::Point* position);

  // required float heading = 2;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 2;
  inline float heading() const;
  inline void set_heading(float value);

  // required .lunabotics.proto.Twist velocities = 3;
  inline bool has_velocities() const;
  inline void clear_velocities();
  static const int kVelocitiesFieldNumber = 3;
  inline const ::lunabotics::proto::Twist& velocities() const;
  inline ::lunabotics::proto::Twist* mutable_velocities();
  inline ::lunabotics::proto::Twist* release_velocities();
  inline void set_allocated_velocities(::lunabotics::proto::Twist* velocities);

  // required .lunabotics.proto.SteeringModeType steering_mode = 4;
  inline bool has_steering_mode() const;
  inline void clear_steering_mode();
  static const int kSteeringModeFieldNumber = 4;
  inline ::lunabotics::proto::SteeringModeType steering_mode() const;
  inline void set_steering_mode(::lunabotics::proto::SteeringModeType value);

  // required bool autonomy_enabled = 5;
  inline bool has_autonomy_enabled() const;
  inline void clear_autonomy_enabled();
  static const int kAutonomyEnabledFieldNumber = 5;
  inline bool autonomy_enabled() const;
  inline void set_autonomy_enabled(bool value);

  // optional int32 next_waypoint_idx = 6;
  inline bool has_next_waypoint_idx() const;
  inline void clear_next_waypoint_idx();
  static const int kNextWaypointIdxFieldNumber = 6;
  inline ::google::protobuf::int32 next_waypoint_idx() const;
  inline void set_next_waypoint_idx(::google::protobuf::int32 value);

  // optional .lunabotics.proto.Point icr = 7;
  inline bool has_icr() const;
  inline void clear_icr();
  static const int kIcrFieldNumber = 7;
  inline const ::lunabotics::proto::Point& icr() const;
  inline ::lunabotics::proto::Point* mutable_icr();
  inline ::lunabotics::proto::Point* release_icr();
  inline void set_allocated_icr(::lunabotics::proto::Point* icr);

  // optional .lunabotics.proto.Telemetry.State.AckermannTelemetry ackermann_telemetry = 8;
  inline bool has_ackermann_telemetry() const;
  inline void clear_ackermann_telemetry();
  static const int kAckermannTelemetryFieldNumber = 8;
  inline const ::lunabotics::proto::Telemetry_State_AckermannTelemetry& ackermann_telemetry() const;
  inline ::lunabotics::proto::Telemetry_State_AckermannTelemetry* mutable_ackermann_telemetry();
  inline ::lunabotics::proto::Telemetry_State_AckermannTelemetry* release_ackermann_telemetry();
  inline void set_allocated_ackermann_telemetry(::lunabotics::proto::Telemetry_State_AckermannTelemetry* ackermann_telemetry);

  // optional .lunabotics.proto.Telemetry.State.PointTurnTelemetry point_turn_telemetry = 9;
  inline bool has_point_turn_telemetry() const;
  inline void clear_point_turn_telemetry();
  static const int kPointTurnTelemetryFieldNumber = 9;
  inline const ::lunabotics::proto::Telemetry_State_PointTurnTelemetry& point_turn_telemetry() const;
  inline ::lunabotics::proto::Telemetry_State_PointTurnTelemetry* mutable_point_turn_telemetry();
  inline ::lunabotics::proto::Telemetry_State_PointTurnTelemetry* release_point_turn_telemetry();
  inline void set_allocated_point_turn_telemetry(::lunabotics::proto::Telemetry_State_PointTurnTelemetry* point_turn_telemetry);

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telemetry.State)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_velocities();
  inline void clear_has_velocities();
  inline void set_has_steering_mode();
  inline void clear_has_steering_mode();
  inline void set_has_autonomy_enabled();
  inline void clear_has_autonomy_enabled();
  inline void set_has_next_waypoint_idx();
  inline void clear_has_next_waypoint_idx();
  inline void set_has_icr();
  inline void clear_has_icr();
  inline void set_has_ackermann_telemetry();
  inline void clear_has_ackermann_telemetry();
  inline void set_has_point_turn_telemetry();
  inline void clear_has_point_turn_telemetry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::lunabotics::proto::Point* position_;
  ::lunabotics::proto::Twist* velocities_;
  float heading_;
  int steering_mode_;
  bool autonomy_enabled_;
  ::google::protobuf::int32 next_waypoint_idx_;
  ::lunabotics::proto::Point* icr_;
  ::lunabotics::proto::Telemetry_State_AckermannTelemetry* ackermann_telemetry_;
  ::lunabotics::proto::Telemetry_State_PointTurnTelemetry* point_turn_telemetry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_Telemetry_2eproto();
  friend void protobuf_AssignDesc_Telemetry_2eproto();
  friend void protobuf_ShutdownFile_Telemetry_2eproto();

  void InitAsDefaultInstance();
  static Telemetry_State* default_instance_;
};
// -------------------------------------------------------------------

class Telemetry_World : public ::google::protobuf::Message {
 public:
  Telemetry_World();
  virtual ~Telemetry_World();

  Telemetry_World(const Telemetry_World& from);

  inline Telemetry_World& operator=(const Telemetry_World& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telemetry_World& default_instance();

  void Swap(Telemetry_World* other);

  // implements Message ----------------------------------------------

  Telemetry_World* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telemetry_World& from);
  void MergeFrom(const Telemetry_World& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // required int32 height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // required float resolution = 3;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 3;
  inline float resolution() const;
  inline void set_resolution(float value);

  // repeated int32 cell = 4 [packed = true];
  inline int cell_size() const;
  inline void clear_cell();
  static const int kCellFieldNumber = 4;
  inline ::google::protobuf::int32 cell(int index) const;
  inline void set_cell(int index, ::google::protobuf::int32 value);
  inline void add_cell(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      cell() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_cell();

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telemetry.World)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_resolution();
  inline void clear_has_resolution();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > cell_;
  mutable int _cell_cached_byte_size_;
  float resolution_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Telemetry_2eproto();
  friend void protobuf_AssignDesc_Telemetry_2eproto();
  friend void protobuf_ShutdownFile_Telemetry_2eproto();

  void InitAsDefaultInstance();
  static Telemetry_World* default_instance_;
};
// -------------------------------------------------------------------

class Telemetry_Path : public ::google::protobuf::Message {
 public:
  Telemetry_Path();
  virtual ~Telemetry_Path();

  Telemetry_Path(const Telemetry_Path& from);

  inline Telemetry_Path& operator=(const Telemetry_Path& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telemetry_Path& default_instance();

  void Swap(Telemetry_Path* other);

  // implements Message ----------------------------------------------

  Telemetry_Path* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telemetry_Path& from);
  void MergeFrom(const Telemetry_Path& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lunabotics.proto.Point position = 1;
  inline int position_size() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::lunabotics::proto::Point& position(int index) const;
  inline ::lunabotics::proto::Point* mutable_position(int index);
  inline ::lunabotics::proto::Point* add_position();
  inline const ::google::protobuf::RepeatedPtrField< ::lunabotics::proto::Point >&
      position() const;
  inline ::google::protobuf::RepeatedPtrField< ::lunabotics::proto::Point >*
      mutable_position();

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telemetry.Path)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::lunabotics::proto::Point > position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Telemetry_2eproto();
  friend void protobuf_AssignDesc_Telemetry_2eproto();
  friend void protobuf_ShutdownFile_Telemetry_2eproto();

  void InitAsDefaultInstance();
  static Telemetry_Path* default_instance_;
};
// -------------------------------------------------------------------

class Telemetry_LaserScan : public ::google::protobuf::Message {
 public:
  Telemetry_LaserScan();
  virtual ~Telemetry_LaserScan();

  Telemetry_LaserScan(const Telemetry_LaserScan& from);

  inline Telemetry_LaserScan& operator=(const Telemetry_LaserScan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telemetry_LaserScan& default_instance();

  void Swap(Telemetry_LaserScan* other);

  // implements Message ----------------------------------------------

  Telemetry_LaserScan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telemetry_LaserScan& from);
  void MergeFrom(const Telemetry_LaserScan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telemetry.LaserScan)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_Telemetry_2eproto();
  friend void protobuf_AssignDesc_Telemetry_2eproto();
  friend void protobuf_ShutdownFile_Telemetry_2eproto();

  void InitAsDefaultInstance();
  static Telemetry_LaserScan* default_instance_;
};
// -------------------------------------------------------------------

class Telemetry_Geometry : public ::google::protobuf::Message {
 public:
  Telemetry_Geometry();
  virtual ~Telemetry_Geometry();

  Telemetry_Geometry(const Telemetry_Geometry& from);

  inline Telemetry_Geometry& operator=(const Telemetry_Geometry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telemetry_Geometry& default_instance();

  void Swap(Telemetry_Geometry* other);

  // implements Message ----------------------------------------------

  Telemetry_Geometry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telemetry_Geometry& from);
  void MergeFrom(const Telemetry_Geometry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .lunabotics.proto.Point left_front_joint = 1;
  inline bool has_left_front_joint() const;
  inline void clear_left_front_joint();
  static const int kLeftFrontJointFieldNumber = 1;
  inline const ::lunabotics::proto::Point& left_front_joint() const;
  inline ::lunabotics::proto::Point* mutable_left_front_joint();
  inline ::lunabotics::proto::Point* release_left_front_joint();
  inline void set_allocated_left_front_joint(::lunabotics::proto::Point* left_front_joint);

  // required .lunabotics.proto.Point left_rear_joint = 2;
  inline bool has_left_rear_joint() const;
  inline void clear_left_rear_joint();
  static const int kLeftRearJointFieldNumber = 2;
  inline const ::lunabotics::proto::Point& left_rear_joint() const;
  inline ::lunabotics::proto::Point* mutable_left_rear_joint();
  inline ::lunabotics::proto::Point* release_left_rear_joint();
  inline void set_allocated_left_rear_joint(::lunabotics::proto::Point* left_rear_joint);

  // required .lunabotics.proto.Point right_front_joint = 3;
  inline bool has_right_front_joint() const;
  inline void clear_right_front_joint();
  static const int kRightFrontJointFieldNumber = 3;
  inline const ::lunabotics::proto::Point& right_front_joint() const;
  inline ::lunabotics::proto::Point* mutable_right_front_joint();
  inline ::lunabotics::proto::Point* release_right_front_joint();
  inline void set_allocated_right_front_joint(::lunabotics::proto::Point* right_front_joint);

  // required .lunabotics.proto.Point right_rear_joint = 4;
  inline bool has_right_rear_joint() const;
  inline void clear_right_rear_joint();
  static const int kRightRearJointFieldNumber = 4;
  inline const ::lunabotics::proto::Point& right_rear_joint() const;
  inline ::lunabotics::proto::Point* mutable_right_rear_joint();
  inline ::lunabotics::proto::Point* release_right_rear_joint();
  inline void set_allocated_right_rear_joint(::lunabotics::proto::Point* right_rear_joint);

  // required float wheel_offset = 5;
  inline bool has_wheel_offset() const;
  inline void clear_wheel_offset();
  static const int kWheelOffsetFieldNumber = 5;
  inline float wheel_offset() const;
  inline void set_wheel_offset(float value);

  // required float wheel_radius = 6;
  inline bool has_wheel_radius() const;
  inline void clear_wheel_radius();
  static const int kWheelRadiusFieldNumber = 6;
  inline float wheel_radius() const;
  inline void set_wheel_radius(float value);

  // required float wheel_width = 7;
  inline bool has_wheel_width() const;
  inline void clear_wheel_width();
  static const int kWheelWidthFieldNumber = 7;
  inline float wheel_width() const;
  inline void set_wheel_width(float value);

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telemetry.Geometry)
 private:
  inline void set_has_left_front_joint();
  inline void clear_has_left_front_joint();
  inline void set_has_left_rear_joint();
  inline void clear_has_left_rear_joint();
  inline void set_has_right_front_joint();
  inline void clear_has_right_front_joint();
  inline void set_has_right_rear_joint();
  inline void clear_has_right_rear_joint();
  inline void set_has_wheel_offset();
  inline void clear_has_wheel_offset();
  inline void set_has_wheel_radius();
  inline void clear_has_wheel_radius();
  inline void set_has_wheel_width();
  inline void clear_has_wheel_width();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::lunabotics::proto::Point* left_front_joint_;
  ::lunabotics::proto::Point* left_rear_joint_;
  ::lunabotics::proto::Point* right_front_joint_;
  ::lunabotics::proto::Point* right_rear_joint_;
  float wheel_offset_;
  float wheel_radius_;
  float wheel_width_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Telemetry_2eproto();
  friend void protobuf_AssignDesc_Telemetry_2eproto();
  friend void protobuf_ShutdownFile_Telemetry_2eproto();

  void InitAsDefaultInstance();
  static Telemetry_Geometry* default_instance_;
};
// -------------------------------------------------------------------

class Telemetry : public ::google::protobuf::Message {
 public:
  Telemetry();
  virtual ~Telemetry();

  Telemetry(const Telemetry& from);

  inline Telemetry& operator=(const Telemetry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telemetry& default_instance();

  void Swap(Telemetry* other);

  // implements Message ----------------------------------------------

  Telemetry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telemetry& from);
  void MergeFrom(const Telemetry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Telemetry_State State;
  typedef Telemetry_World World;
  typedef Telemetry_Path Path;
  typedef Telemetry_LaserScan LaserScan;
  typedef Telemetry_Geometry Geometry;

  typedef Telemetry_PointTurnState PointTurnState;
  static const PointTurnState STOPPED = Telemetry_PointTurnState_STOPPED;
  static const PointTurnState DRIVING = Telemetry_PointTurnState_DRIVING;
  static const PointTurnState TURNING = Telemetry_PointTurnState_TURNING;
  static inline bool PointTurnState_IsValid(int value) {
    return Telemetry_PointTurnState_IsValid(value);
  }
  static const PointTurnState PointTurnState_MIN =
    Telemetry_PointTurnState_PointTurnState_MIN;
  static const PointTurnState PointTurnState_MAX =
    Telemetry_PointTurnState_PointTurnState_MAX;
  static const int PointTurnState_ARRAYSIZE =
    Telemetry_PointTurnState_PointTurnState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PointTurnState_descriptor() {
    return Telemetry_PointTurnState_descriptor();
  }
  static inline const ::std::string& PointTurnState_Name(PointTurnState value) {
    return Telemetry_PointTurnState_Name(value);
  }
  static inline bool PointTurnState_Parse(const ::std::string& name,
      PointTurnState* value) {
    return Telemetry_PointTurnState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .lunabotics.proto.Telemetry.State state_data = 2;
  inline bool has_state_data() const;
  inline void clear_state_data();
  static const int kStateDataFieldNumber = 2;
  inline const ::lunabotics::proto::Telemetry_State& state_data() const;
  inline ::lunabotics::proto::Telemetry_State* mutable_state_data();
  inline ::lunabotics::proto::Telemetry_State* release_state_data();
  inline void set_allocated_state_data(::lunabotics::proto::Telemetry_State* state_data);

  // optional .lunabotics.proto.Telemetry.World world_data = 3;
  inline bool has_world_data() const;
  inline void clear_world_data();
  static const int kWorldDataFieldNumber = 3;
  inline const ::lunabotics::proto::Telemetry_World& world_data() const;
  inline ::lunabotics::proto::Telemetry_World* mutable_world_data();
  inline ::lunabotics::proto::Telemetry_World* release_world_data();
  inline void set_allocated_world_data(::lunabotics::proto::Telemetry_World* world_data);

  // optional .lunabotics.proto.Telemetry.Path path_data = 4;
  inline bool has_path_data() const;
  inline void clear_path_data();
  static const int kPathDataFieldNumber = 4;
  inline const ::lunabotics::proto::Telemetry_Path& path_data() const;
  inline ::lunabotics::proto::Telemetry_Path* mutable_path_data();
  inline ::lunabotics::proto::Telemetry_Path* release_path_data();
  inline void set_allocated_path_data(::lunabotics::proto::Telemetry_Path* path_data);

  // optional .lunabotics.proto.Telemetry.LaserScan laser_scan_data = 5;
  inline bool has_laser_scan_data() const;
  inline void clear_laser_scan_data();
  static const int kLaserScanDataFieldNumber = 5;
  inline const ::lunabotics::proto::Telemetry_LaserScan& laser_scan_data() const;
  inline ::lunabotics::proto::Telemetry_LaserScan* mutable_laser_scan_data();
  inline ::lunabotics::proto::Telemetry_LaserScan* release_laser_scan_data();
  inline void set_allocated_laser_scan_data(::lunabotics::proto::Telemetry_LaserScan* laser_scan_data);

  // optional .lunabotics.proto.AllWheelState all_wheel_state = 6;
  inline bool has_all_wheel_state() const;
  inline void clear_all_wheel_state();
  static const int kAllWheelStateFieldNumber = 6;
  inline const ::lunabotics::proto::AllWheelState& all_wheel_state() const;
  inline ::lunabotics::proto::AllWheelState* mutable_all_wheel_state();
  inline ::lunabotics::proto::AllWheelState* release_all_wheel_state();
  inline void set_allocated_all_wheel_state(::lunabotics::proto::AllWheelState* all_wheel_state);

  // optional .lunabotics.proto.Telemetry.Geometry geometry_data = 7;
  inline bool has_geometry_data() const;
  inline void clear_geometry_data();
  static const int kGeometryDataFieldNumber = 7;
  inline const ::lunabotics::proto::Telemetry_Geometry& geometry_data() const;
  inline ::lunabotics::proto::Telemetry_Geometry* mutable_geometry_data();
  inline ::lunabotics::proto::Telemetry_Geometry* release_geometry_data();
  inline void set_allocated_geometry_data(::lunabotics::proto::Telemetry_Geometry* geometry_data);

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telemetry)
 private:
  inline void set_has_state_data();
  inline void clear_has_state_data();
  inline void set_has_world_data();
  inline void clear_has_world_data();
  inline void set_has_path_data();
  inline void clear_has_path_data();
  inline void set_has_laser_scan_data();
  inline void clear_has_laser_scan_data();
  inline void set_has_all_wheel_state();
  inline void clear_has_all_wheel_state();
  inline void set_has_geometry_data();
  inline void clear_has_geometry_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::lunabotics::proto::Telemetry_State* state_data_;
  ::lunabotics::proto::Telemetry_World* world_data_;
  ::lunabotics::proto::Telemetry_Path* path_data_;
  ::lunabotics::proto::Telemetry_LaserScan* laser_scan_data_;
  ::lunabotics::proto::AllWheelState* all_wheel_state_;
  ::lunabotics::proto::Telemetry_Geometry* geometry_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Telemetry_2eproto();
  friend void protobuf_AssignDesc_Telemetry_2eproto();
  friend void protobuf_ShutdownFile_Telemetry_2eproto();

  void InitAsDefaultInstance();
  static Telemetry* default_instance_;
};
// ===================================================================


// ===================================================================

// Telemetry_State_AckermannTelemetry

// required float pid_error = 1;
inline bool Telemetry_State_AckermannTelemetry::has_pid_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telemetry_State_AckermannTelemetry::set_has_pid_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telemetry_State_AckermannTelemetry::clear_has_pid_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telemetry_State_AckermannTelemetry::clear_pid_error() {
  pid_error_ = 0;
  clear_has_pid_error();
}
inline float Telemetry_State_AckermannTelemetry::pid_error() const {
  return pid_error_;
}
inline void Telemetry_State_AckermannTelemetry::set_pid_error(float value) {
  set_has_pid_error();
  pid_error_ = value;
}

// required .lunabotics.proto.Point closest_trajectory_point = 2;
inline bool Telemetry_State_AckermannTelemetry::has_closest_trajectory_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Telemetry_State_AckermannTelemetry::set_has_closest_trajectory_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Telemetry_State_AckermannTelemetry::clear_has_closest_trajectory_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Telemetry_State_AckermannTelemetry::clear_closest_trajectory_point() {
  if (closest_trajectory_point_ != NULL) closest_trajectory_point_->::lunabotics::proto::Point::Clear();
  clear_has_closest_trajectory_point();
}
inline const ::lunabotics::proto::Point& Telemetry_State_AckermannTelemetry::closest_trajectory_point() const {
  return closest_trajectory_point_ != NULL ? *closest_trajectory_point_ : *default_instance_->closest_trajectory_point_;
}
inline ::lunabotics::proto::Point* Telemetry_State_AckermannTelemetry::mutable_closest_trajectory_point() {
  set_has_closest_trajectory_point();
  if (closest_trajectory_point_ == NULL) closest_trajectory_point_ = new ::lunabotics::proto::Point;
  return closest_trajectory_point_;
}
inline ::lunabotics::proto::Point* Telemetry_State_AckermannTelemetry::release_closest_trajectory_point() {
  clear_has_closest_trajectory_point();
  ::lunabotics::proto::Point* temp = closest_trajectory_point_;
  closest_trajectory_point_ = NULL;
  return temp;
}
inline void Telemetry_State_AckermannTelemetry::set_allocated_closest_trajectory_point(::lunabotics::proto::Point* closest_trajectory_point) {
  delete closest_trajectory_point_;
  closest_trajectory_point_ = closest_trajectory_point;
  if (closest_trajectory_point) {
    set_has_closest_trajectory_point();
  } else {
    clear_has_closest_trajectory_point();
  }
}

// required .lunabotics.proto.Point velocity_vector_point = 3;
inline bool Telemetry_State_AckermannTelemetry::has_velocity_vector_point() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Telemetry_State_AckermannTelemetry::set_has_velocity_vector_point() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Telemetry_State_AckermannTelemetry::clear_has_velocity_vector_point() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Telemetry_State_AckermannTelemetry::clear_velocity_vector_point() {
  if (velocity_vector_point_ != NULL) velocity_vector_point_->::lunabotics::proto::Point::Clear();
  clear_has_velocity_vector_point();
}
inline const ::lunabotics::proto::Point& Telemetry_State_AckermannTelemetry::velocity_vector_point() const {
  return velocity_vector_point_ != NULL ? *velocity_vector_point_ : *default_instance_->velocity_vector_point_;
}
inline ::lunabotics::proto::Point* Telemetry_State_AckermannTelemetry::mutable_velocity_vector_point() {
  set_has_velocity_vector_point();
  if (velocity_vector_point_ == NULL) velocity_vector_point_ = new ::lunabotics::proto::Point;
  return velocity_vector_point_;
}
inline ::lunabotics::proto::Point* Telemetry_State_AckermannTelemetry::release_velocity_vector_point() {
  clear_has_velocity_vector_point();
  ::lunabotics::proto::Point* temp = velocity_vector_point_;
  velocity_vector_point_ = NULL;
  return temp;
}
inline void Telemetry_State_AckermannTelemetry::set_allocated_velocity_vector_point(::lunabotics::proto::Point* velocity_vector_point) {
  delete velocity_vector_point_;
  velocity_vector_point_ = velocity_vector_point;
  if (velocity_vector_point) {
    set_has_velocity_vector_point();
  } else {
    clear_has_velocity_vector_point();
  }
}

// required .lunabotics.proto.Point closest_trajectory_local_point = 4;
inline bool Telemetry_State_AckermannTelemetry::has_closest_trajectory_local_point() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Telemetry_State_AckermannTelemetry::set_has_closest_trajectory_local_point() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Telemetry_State_AckermannTelemetry::clear_has_closest_trajectory_local_point() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Telemetry_State_AckermannTelemetry::clear_closest_trajectory_local_point() {
  if (closest_trajectory_local_point_ != NULL) closest_trajectory_local_point_->::lunabotics::proto::Point::Clear();
  clear_has_closest_trajectory_local_point();
}
inline const ::lunabotics::proto::Point& Telemetry_State_AckermannTelemetry::closest_trajectory_local_point() const {
  return closest_trajectory_local_point_ != NULL ? *closest_trajectory_local_point_ : *default_instance_->closest_trajectory_local_point_;
}
inline ::lunabotics::proto::Point* Telemetry_State_AckermannTelemetry::mutable_closest_trajectory_local_point() {
  set_has_closest_trajectory_local_point();
  if (closest_trajectory_local_point_ == NULL) closest_trajectory_local_point_ = new ::lunabotics::proto::Point;
  return closest_trajectory_local_point_;
}
inline ::lunabotics::proto::Point* Telemetry_State_AckermannTelemetry::release_closest_trajectory_local_point() {
  clear_has_closest_trajectory_local_point();
  ::lunabotics::proto::Point* temp = closest_trajectory_local_point_;
  closest_trajectory_local_point_ = NULL;
  return temp;
}
inline void Telemetry_State_AckermannTelemetry::set_allocated_closest_trajectory_local_point(::lunabotics::proto::Point* closest_trajectory_local_point) {
  delete closest_trajectory_local_point_;
  closest_trajectory_local_point_ = closest_trajectory_local_point;
  if (closest_trajectory_local_point) {
    set_has_closest_trajectory_local_point();
  } else {
    clear_has_closest_trajectory_local_point();
  }
}

// required .lunabotics.proto.Point velocity_vector_local_point = 5;
inline bool Telemetry_State_AckermannTelemetry::has_velocity_vector_local_point() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Telemetry_State_AckermannTelemetry::set_has_velocity_vector_local_point() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Telemetry_State_AckermannTelemetry::clear_has_velocity_vector_local_point() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Telemetry_State_AckermannTelemetry::clear_velocity_vector_local_point() {
  if (velocity_vector_local_point_ != NULL) velocity_vector_local_point_->::lunabotics::proto::Point::Clear();
  clear_has_velocity_vector_local_point();
}
inline const ::lunabotics::proto::Point& Telemetry_State_AckermannTelemetry::velocity_vector_local_point() const {
  return velocity_vector_local_point_ != NULL ? *velocity_vector_local_point_ : *default_instance_->velocity_vector_local_point_;
}
inline ::lunabotics::proto::Point* Telemetry_State_AckermannTelemetry::mutable_velocity_vector_local_point() {
  set_has_velocity_vector_local_point();
  if (velocity_vector_local_point_ == NULL) velocity_vector_local_point_ = new ::lunabotics::proto::Point;
  return velocity_vector_local_point_;
}
inline ::lunabotics::proto::Point* Telemetry_State_AckermannTelemetry::release_velocity_vector_local_point() {
  clear_has_velocity_vector_local_point();
  ::lunabotics::proto::Point* temp = velocity_vector_local_point_;
  velocity_vector_local_point_ = NULL;
  return temp;
}
inline void Telemetry_State_AckermannTelemetry::set_allocated_velocity_vector_local_point(::lunabotics::proto::Point* velocity_vector_local_point) {
  delete velocity_vector_local_point_;
  velocity_vector_local_point_ = velocity_vector_local_point;
  if (velocity_vector_local_point) {
    set_has_velocity_vector_local_point();
  } else {
    clear_has_velocity_vector_local_point();
  }
}

// -------------------------------------------------------------------

// Telemetry_State_PointTurnTelemetry

// required .lunabotics.proto.Telemetry.PointTurnState state = 1;
inline bool Telemetry_State_PointTurnTelemetry::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telemetry_State_PointTurnTelemetry::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telemetry_State_PointTurnTelemetry::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telemetry_State_PointTurnTelemetry::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::lunabotics::proto::Telemetry_PointTurnState Telemetry_State_PointTurnTelemetry::state() const {
  return static_cast< ::lunabotics::proto::Telemetry_PointTurnState >(state_);
}
inline void Telemetry_State_PointTurnTelemetry::set_state(::lunabotics::proto::Telemetry_PointTurnState value) {
  assert(::lunabotics::proto::Telemetry_PointTurnState_IsValid(value));
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// Telemetry_State

// required .lunabotics.proto.Point position = 1;
inline bool Telemetry_State::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telemetry_State::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telemetry_State::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telemetry_State::clear_position() {
  if (position_ != NULL) position_->::lunabotics::proto::Point::Clear();
  clear_has_position();
}
inline const ::lunabotics::proto::Point& Telemetry_State::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::lunabotics::proto::Point* Telemetry_State::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::lunabotics::proto::Point;
  return position_;
}
inline ::lunabotics::proto::Point* Telemetry_State::release_position() {
  clear_has_position();
  ::lunabotics::proto::Point* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Telemetry_State::set_allocated_position(::lunabotics::proto::Point* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// required float heading = 2;
inline bool Telemetry_State::has_heading() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Telemetry_State::set_has_heading() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Telemetry_State::clear_has_heading() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Telemetry_State::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline float Telemetry_State::heading() const {
  return heading_;
}
inline void Telemetry_State::set_heading(float value) {
  set_has_heading();
  heading_ = value;
}

// required .lunabotics.proto.Twist velocities = 3;
inline bool Telemetry_State::has_velocities() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Telemetry_State::set_has_velocities() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Telemetry_State::clear_has_velocities() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Telemetry_State::clear_velocities() {
  if (velocities_ != NULL) velocities_->::lunabotics::proto::Twist::Clear();
  clear_has_velocities();
}
inline const ::lunabotics::proto::Twist& Telemetry_State::velocities() const {
  return velocities_ != NULL ? *velocities_ : *default_instance_->velocities_;
}
inline ::lunabotics::proto::Twist* Telemetry_State::mutable_velocities() {
  set_has_velocities();
  if (velocities_ == NULL) velocities_ = new ::lunabotics::proto::Twist;
  return velocities_;
}
inline ::lunabotics::proto::Twist* Telemetry_State::release_velocities() {
  clear_has_velocities();
  ::lunabotics::proto::Twist* temp = velocities_;
  velocities_ = NULL;
  return temp;
}
inline void Telemetry_State::set_allocated_velocities(::lunabotics::proto::Twist* velocities) {
  delete velocities_;
  velocities_ = velocities;
  if (velocities) {
    set_has_velocities();
  } else {
    clear_has_velocities();
  }
}

// required .lunabotics.proto.SteeringModeType steering_mode = 4;
inline bool Telemetry_State::has_steering_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Telemetry_State::set_has_steering_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Telemetry_State::clear_has_steering_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Telemetry_State::clear_steering_mode() {
  steering_mode_ = 1;
  clear_has_steering_mode();
}
inline ::lunabotics::proto::SteeringModeType Telemetry_State::steering_mode() const {
  return static_cast< ::lunabotics::proto::SteeringModeType >(steering_mode_);
}
inline void Telemetry_State::set_steering_mode(::lunabotics::proto::SteeringModeType value) {
  assert(::lunabotics::proto::SteeringModeType_IsValid(value));
  set_has_steering_mode();
  steering_mode_ = value;
}

// required bool autonomy_enabled = 5;
inline bool Telemetry_State::has_autonomy_enabled() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Telemetry_State::set_has_autonomy_enabled() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Telemetry_State::clear_has_autonomy_enabled() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Telemetry_State::clear_autonomy_enabled() {
  autonomy_enabled_ = false;
  clear_has_autonomy_enabled();
}
inline bool Telemetry_State::autonomy_enabled() const {
  return autonomy_enabled_;
}
inline void Telemetry_State::set_autonomy_enabled(bool value) {
  set_has_autonomy_enabled();
  autonomy_enabled_ = value;
}

// optional int32 next_waypoint_idx = 6;
inline bool Telemetry_State::has_next_waypoint_idx() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Telemetry_State::set_has_next_waypoint_idx() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Telemetry_State::clear_has_next_waypoint_idx() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Telemetry_State::clear_next_waypoint_idx() {
  next_waypoint_idx_ = 0;
  clear_has_next_waypoint_idx();
}
inline ::google::protobuf::int32 Telemetry_State::next_waypoint_idx() const {
  return next_waypoint_idx_;
}
inline void Telemetry_State::set_next_waypoint_idx(::google::protobuf::int32 value) {
  set_has_next_waypoint_idx();
  next_waypoint_idx_ = value;
}

// optional .lunabotics.proto.Point icr = 7;
inline bool Telemetry_State::has_icr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Telemetry_State::set_has_icr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Telemetry_State::clear_has_icr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Telemetry_State::clear_icr() {
  if (icr_ != NULL) icr_->::lunabotics::proto::Point::Clear();
  clear_has_icr();
}
inline const ::lunabotics::proto::Point& Telemetry_State::icr() const {
  return icr_ != NULL ? *icr_ : *default_instance_->icr_;
}
inline ::lunabotics::proto::Point* Telemetry_State::mutable_icr() {
  set_has_icr();
  if (icr_ == NULL) icr_ = new ::lunabotics::proto::Point;
  return icr_;
}
inline ::lunabotics::proto::Point* Telemetry_State::release_icr() {
  clear_has_icr();
  ::lunabotics::proto::Point* temp = icr_;
  icr_ = NULL;
  return temp;
}
inline void Telemetry_State::set_allocated_icr(::lunabotics::proto::Point* icr) {
  delete icr_;
  icr_ = icr;
  if (icr) {
    set_has_icr();
  } else {
    clear_has_icr();
  }
}

// optional .lunabotics.proto.Telemetry.State.AckermannTelemetry ackermann_telemetry = 8;
inline bool Telemetry_State::has_ackermann_telemetry() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Telemetry_State::set_has_ackermann_telemetry() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Telemetry_State::clear_has_ackermann_telemetry() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Telemetry_State::clear_ackermann_telemetry() {
  if (ackermann_telemetry_ != NULL) ackermann_telemetry_->::lunabotics::proto::Telemetry_State_AckermannTelemetry::Clear();
  clear_has_ackermann_telemetry();
}
inline const ::lunabotics::proto::Telemetry_State_AckermannTelemetry& Telemetry_State::ackermann_telemetry() const {
  return ackermann_telemetry_ != NULL ? *ackermann_telemetry_ : *default_instance_->ackermann_telemetry_;
}
inline ::lunabotics::proto::Telemetry_State_AckermannTelemetry* Telemetry_State::mutable_ackermann_telemetry() {
  set_has_ackermann_telemetry();
  if (ackermann_telemetry_ == NULL) ackermann_telemetry_ = new ::lunabotics::proto::Telemetry_State_AckermannTelemetry;
  return ackermann_telemetry_;
}
inline ::lunabotics::proto::Telemetry_State_AckermannTelemetry* Telemetry_State::release_ackermann_telemetry() {
  clear_has_ackermann_telemetry();
  ::lunabotics::proto::Telemetry_State_AckermannTelemetry* temp = ackermann_telemetry_;
  ackermann_telemetry_ = NULL;
  return temp;
}
inline void Telemetry_State::set_allocated_ackermann_telemetry(::lunabotics::proto::Telemetry_State_AckermannTelemetry* ackermann_telemetry) {
  delete ackermann_telemetry_;
  ackermann_telemetry_ = ackermann_telemetry;
  if (ackermann_telemetry) {
    set_has_ackermann_telemetry();
  } else {
    clear_has_ackermann_telemetry();
  }
}

// optional .lunabotics.proto.Telemetry.State.PointTurnTelemetry point_turn_telemetry = 9;
inline bool Telemetry_State::has_point_turn_telemetry() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Telemetry_State::set_has_point_turn_telemetry() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Telemetry_State::clear_has_point_turn_telemetry() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Telemetry_State::clear_point_turn_telemetry() {
  if (point_turn_telemetry_ != NULL) point_turn_telemetry_->::lunabotics::proto::Telemetry_State_PointTurnTelemetry::Clear();
  clear_has_point_turn_telemetry();
}
inline const ::lunabotics::proto::Telemetry_State_PointTurnTelemetry& Telemetry_State::point_turn_telemetry() const {
  return point_turn_telemetry_ != NULL ? *point_turn_telemetry_ : *default_instance_->point_turn_telemetry_;
}
inline ::lunabotics::proto::Telemetry_State_PointTurnTelemetry* Telemetry_State::mutable_point_turn_telemetry() {
  set_has_point_turn_telemetry();
  if (point_turn_telemetry_ == NULL) point_turn_telemetry_ = new ::lunabotics::proto::Telemetry_State_PointTurnTelemetry;
  return point_turn_telemetry_;
}
inline ::lunabotics::proto::Telemetry_State_PointTurnTelemetry* Telemetry_State::release_point_turn_telemetry() {
  clear_has_point_turn_telemetry();
  ::lunabotics::proto::Telemetry_State_PointTurnTelemetry* temp = point_turn_telemetry_;
  point_turn_telemetry_ = NULL;
  return temp;
}
inline void Telemetry_State::set_allocated_point_turn_telemetry(::lunabotics::proto::Telemetry_State_PointTurnTelemetry* point_turn_telemetry) {
  delete point_turn_telemetry_;
  point_turn_telemetry_ = point_turn_telemetry;
  if (point_turn_telemetry) {
    set_has_point_turn_telemetry();
  } else {
    clear_has_point_turn_telemetry();
  }
}

// -------------------------------------------------------------------

// Telemetry_World

// required int32 width = 1;
inline bool Telemetry_World::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telemetry_World::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telemetry_World::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telemetry_World::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Telemetry_World::width() const {
  return width_;
}
inline void Telemetry_World::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// required int32 height = 2;
inline bool Telemetry_World::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Telemetry_World::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Telemetry_World::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Telemetry_World::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Telemetry_World::height() const {
  return height_;
}
inline void Telemetry_World::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// required float resolution = 3;
inline bool Telemetry_World::has_resolution() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Telemetry_World::set_has_resolution() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Telemetry_World::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Telemetry_World::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
inline float Telemetry_World::resolution() const {
  return resolution_;
}
inline void Telemetry_World::set_resolution(float value) {
  set_has_resolution();
  resolution_ = value;
}

// repeated int32 cell = 4 [packed = true];
inline int Telemetry_World::cell_size() const {
  return cell_.size();
}
inline void Telemetry_World::clear_cell() {
  cell_.Clear();
}
inline ::google::protobuf::int32 Telemetry_World::cell(int index) const {
  return cell_.Get(index);
}
inline void Telemetry_World::set_cell(int index, ::google::protobuf::int32 value) {
  cell_.Set(index, value);
}
inline void Telemetry_World::add_cell(::google::protobuf::int32 value) {
  cell_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Telemetry_World::cell() const {
  return cell_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Telemetry_World::mutable_cell() {
  return &cell_;
}

// -------------------------------------------------------------------

// Telemetry_Path

// repeated .lunabotics.proto.Point position = 1;
inline int Telemetry_Path::position_size() const {
  return position_.size();
}
inline void Telemetry_Path::clear_position() {
  position_.Clear();
}
inline const ::lunabotics::proto::Point& Telemetry_Path::position(int index) const {
  return position_.Get(index);
}
inline ::lunabotics::proto::Point* Telemetry_Path::mutable_position(int index) {
  return position_.Mutable(index);
}
inline ::lunabotics::proto::Point* Telemetry_Path::add_position() {
  return position_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lunabotics::proto::Point >&
Telemetry_Path::position() const {
  return position_;
}
inline ::google::protobuf::RepeatedPtrField< ::lunabotics::proto::Point >*
Telemetry_Path::mutable_position() {
  return &position_;
}

// -------------------------------------------------------------------

// Telemetry_LaserScan

// -------------------------------------------------------------------

// Telemetry_Geometry

// required .lunabotics.proto.Point left_front_joint = 1;
inline bool Telemetry_Geometry::has_left_front_joint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telemetry_Geometry::set_has_left_front_joint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telemetry_Geometry::clear_has_left_front_joint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telemetry_Geometry::clear_left_front_joint() {
  if (left_front_joint_ != NULL) left_front_joint_->::lunabotics::proto::Point::Clear();
  clear_has_left_front_joint();
}
inline const ::lunabotics::proto::Point& Telemetry_Geometry::left_front_joint() const {
  return left_front_joint_ != NULL ? *left_front_joint_ : *default_instance_->left_front_joint_;
}
inline ::lunabotics::proto::Point* Telemetry_Geometry::mutable_left_front_joint() {
  set_has_left_front_joint();
  if (left_front_joint_ == NULL) left_front_joint_ = new ::lunabotics::proto::Point;
  return left_front_joint_;
}
inline ::lunabotics::proto::Point* Telemetry_Geometry::release_left_front_joint() {
  clear_has_left_front_joint();
  ::lunabotics::proto::Point* temp = left_front_joint_;
  left_front_joint_ = NULL;
  return temp;
}
inline void Telemetry_Geometry::set_allocated_left_front_joint(::lunabotics::proto::Point* left_front_joint) {
  delete left_front_joint_;
  left_front_joint_ = left_front_joint;
  if (left_front_joint) {
    set_has_left_front_joint();
  } else {
    clear_has_left_front_joint();
  }
}

// required .lunabotics.proto.Point left_rear_joint = 2;
inline bool Telemetry_Geometry::has_left_rear_joint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Telemetry_Geometry::set_has_left_rear_joint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Telemetry_Geometry::clear_has_left_rear_joint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Telemetry_Geometry::clear_left_rear_joint() {
  if (left_rear_joint_ != NULL) left_rear_joint_->::lunabotics::proto::Point::Clear();
  clear_has_left_rear_joint();
}
inline const ::lunabotics::proto::Point& Telemetry_Geometry::left_rear_joint() const {
  return left_rear_joint_ != NULL ? *left_rear_joint_ : *default_instance_->left_rear_joint_;
}
inline ::lunabotics::proto::Point* Telemetry_Geometry::mutable_left_rear_joint() {
  set_has_left_rear_joint();
  if (left_rear_joint_ == NULL) left_rear_joint_ = new ::lunabotics::proto::Point;
  return left_rear_joint_;
}
inline ::lunabotics::proto::Point* Telemetry_Geometry::release_left_rear_joint() {
  clear_has_left_rear_joint();
  ::lunabotics::proto::Point* temp = left_rear_joint_;
  left_rear_joint_ = NULL;
  return temp;
}
inline void Telemetry_Geometry::set_allocated_left_rear_joint(::lunabotics::proto::Point* left_rear_joint) {
  delete left_rear_joint_;
  left_rear_joint_ = left_rear_joint;
  if (left_rear_joint) {
    set_has_left_rear_joint();
  } else {
    clear_has_left_rear_joint();
  }
}

// required .lunabotics.proto.Point right_front_joint = 3;
inline bool Telemetry_Geometry::has_right_front_joint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Telemetry_Geometry::set_has_right_front_joint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Telemetry_Geometry::clear_has_right_front_joint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Telemetry_Geometry::clear_right_front_joint() {
  if (right_front_joint_ != NULL) right_front_joint_->::lunabotics::proto::Point::Clear();
  clear_has_right_front_joint();
}
inline const ::lunabotics::proto::Point& Telemetry_Geometry::right_front_joint() const {
  return right_front_joint_ != NULL ? *right_front_joint_ : *default_instance_->right_front_joint_;
}
inline ::lunabotics::proto::Point* Telemetry_Geometry::mutable_right_front_joint() {
  set_has_right_front_joint();
  if (right_front_joint_ == NULL) right_front_joint_ = new ::lunabotics::proto::Point;
  return right_front_joint_;
}
inline ::lunabotics::proto::Point* Telemetry_Geometry::release_right_front_joint() {
  clear_has_right_front_joint();
  ::lunabotics::proto::Point* temp = right_front_joint_;
  right_front_joint_ = NULL;
  return temp;
}
inline void Telemetry_Geometry::set_allocated_right_front_joint(::lunabotics::proto::Point* right_front_joint) {
  delete right_front_joint_;
  right_front_joint_ = right_front_joint;
  if (right_front_joint) {
    set_has_right_front_joint();
  } else {
    clear_has_right_front_joint();
  }
}

// required .lunabotics.proto.Point right_rear_joint = 4;
inline bool Telemetry_Geometry::has_right_rear_joint() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Telemetry_Geometry::set_has_right_rear_joint() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Telemetry_Geometry::clear_has_right_rear_joint() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Telemetry_Geometry::clear_right_rear_joint() {
  if (right_rear_joint_ != NULL) right_rear_joint_->::lunabotics::proto::Point::Clear();
  clear_has_right_rear_joint();
}
inline const ::lunabotics::proto::Point& Telemetry_Geometry::right_rear_joint() const {
  return right_rear_joint_ != NULL ? *right_rear_joint_ : *default_instance_->right_rear_joint_;
}
inline ::lunabotics::proto::Point* Telemetry_Geometry::mutable_right_rear_joint() {
  set_has_right_rear_joint();
  if (right_rear_joint_ == NULL) right_rear_joint_ = new ::lunabotics::proto::Point;
  return right_rear_joint_;
}
inline ::lunabotics::proto::Point* Telemetry_Geometry::release_right_rear_joint() {
  clear_has_right_rear_joint();
  ::lunabotics::proto::Point* temp = right_rear_joint_;
  right_rear_joint_ = NULL;
  return temp;
}
inline void Telemetry_Geometry::set_allocated_right_rear_joint(::lunabotics::proto::Point* right_rear_joint) {
  delete right_rear_joint_;
  right_rear_joint_ = right_rear_joint;
  if (right_rear_joint) {
    set_has_right_rear_joint();
  } else {
    clear_has_right_rear_joint();
  }
}

// required float wheel_offset = 5;
inline bool Telemetry_Geometry::has_wheel_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Telemetry_Geometry::set_has_wheel_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Telemetry_Geometry::clear_has_wheel_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Telemetry_Geometry::clear_wheel_offset() {
  wheel_offset_ = 0;
  clear_has_wheel_offset();
}
inline float Telemetry_Geometry::wheel_offset() const {
  return wheel_offset_;
}
inline void Telemetry_Geometry::set_wheel_offset(float value) {
  set_has_wheel_offset();
  wheel_offset_ = value;
}

// required float wheel_radius = 6;
inline bool Telemetry_Geometry::has_wheel_radius() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Telemetry_Geometry::set_has_wheel_radius() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Telemetry_Geometry::clear_has_wheel_radius() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Telemetry_Geometry::clear_wheel_radius() {
  wheel_radius_ = 0;
  clear_has_wheel_radius();
}
inline float Telemetry_Geometry::wheel_radius() const {
  return wheel_radius_;
}
inline void Telemetry_Geometry::set_wheel_radius(float value) {
  set_has_wheel_radius();
  wheel_radius_ = value;
}

// required float wheel_width = 7;
inline bool Telemetry_Geometry::has_wheel_width() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Telemetry_Geometry::set_has_wheel_width() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Telemetry_Geometry::clear_has_wheel_width() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Telemetry_Geometry::clear_wheel_width() {
  wheel_width_ = 0;
  clear_has_wheel_width();
}
inline float Telemetry_Geometry::wheel_width() const {
  return wheel_width_;
}
inline void Telemetry_Geometry::set_wheel_width(float value) {
  set_has_wheel_width();
  wheel_width_ = value;
}

// -------------------------------------------------------------------

// Telemetry

// optional .lunabotics.proto.Telemetry.State state_data = 2;
inline bool Telemetry::has_state_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telemetry::set_has_state_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telemetry::clear_has_state_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telemetry::clear_state_data() {
  if (state_data_ != NULL) state_data_->::lunabotics::proto::Telemetry_State::Clear();
  clear_has_state_data();
}
inline const ::lunabotics::proto::Telemetry_State& Telemetry::state_data() const {
  return state_data_ != NULL ? *state_data_ : *default_instance_->state_data_;
}
inline ::lunabotics::proto::Telemetry_State* Telemetry::mutable_state_data() {
  set_has_state_data();
  if (state_data_ == NULL) state_data_ = new ::lunabotics::proto::Telemetry_State;
  return state_data_;
}
inline ::lunabotics::proto::Telemetry_State* Telemetry::release_state_data() {
  clear_has_state_data();
  ::lunabotics::proto::Telemetry_State* temp = state_data_;
  state_data_ = NULL;
  return temp;
}
inline void Telemetry::set_allocated_state_data(::lunabotics::proto::Telemetry_State* state_data) {
  delete state_data_;
  state_data_ = state_data;
  if (state_data) {
    set_has_state_data();
  } else {
    clear_has_state_data();
  }
}

// optional .lunabotics.proto.Telemetry.World world_data = 3;
inline bool Telemetry::has_world_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Telemetry::set_has_world_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Telemetry::clear_has_world_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Telemetry::clear_world_data() {
  if (world_data_ != NULL) world_data_->::lunabotics::proto::Telemetry_World::Clear();
  clear_has_world_data();
}
inline const ::lunabotics::proto::Telemetry_World& Telemetry::world_data() const {
  return world_data_ != NULL ? *world_data_ : *default_instance_->world_data_;
}
inline ::lunabotics::proto::Telemetry_World* Telemetry::mutable_world_data() {
  set_has_world_data();
  if (world_data_ == NULL) world_data_ = new ::lunabotics::proto::Telemetry_World;
  return world_data_;
}
inline ::lunabotics::proto::Telemetry_World* Telemetry::release_world_data() {
  clear_has_world_data();
  ::lunabotics::proto::Telemetry_World* temp = world_data_;
  world_data_ = NULL;
  return temp;
}
inline void Telemetry::set_allocated_world_data(::lunabotics::proto::Telemetry_World* world_data) {
  delete world_data_;
  world_data_ = world_data;
  if (world_data) {
    set_has_world_data();
  } else {
    clear_has_world_data();
  }
}

// optional .lunabotics.proto.Telemetry.Path path_data = 4;
inline bool Telemetry::has_path_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Telemetry::set_has_path_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Telemetry::clear_has_path_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Telemetry::clear_path_data() {
  if (path_data_ != NULL) path_data_->::lunabotics::proto::Telemetry_Path::Clear();
  clear_has_path_data();
}
inline const ::lunabotics::proto::Telemetry_Path& Telemetry::path_data() const {
  return path_data_ != NULL ? *path_data_ : *default_instance_->path_data_;
}
inline ::lunabotics::proto::Telemetry_Path* Telemetry::mutable_path_data() {
  set_has_path_data();
  if (path_data_ == NULL) path_data_ = new ::lunabotics::proto::Telemetry_Path;
  return path_data_;
}
inline ::lunabotics::proto::Telemetry_Path* Telemetry::release_path_data() {
  clear_has_path_data();
  ::lunabotics::proto::Telemetry_Path* temp = path_data_;
  path_data_ = NULL;
  return temp;
}
inline void Telemetry::set_allocated_path_data(::lunabotics::proto::Telemetry_Path* path_data) {
  delete path_data_;
  path_data_ = path_data;
  if (path_data) {
    set_has_path_data();
  } else {
    clear_has_path_data();
  }
}

// optional .lunabotics.proto.Telemetry.LaserScan laser_scan_data = 5;
inline bool Telemetry::has_laser_scan_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Telemetry::set_has_laser_scan_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Telemetry::clear_has_laser_scan_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Telemetry::clear_laser_scan_data() {
  if (laser_scan_data_ != NULL) laser_scan_data_->::lunabotics::proto::Telemetry_LaserScan::Clear();
  clear_has_laser_scan_data();
}
inline const ::lunabotics::proto::Telemetry_LaserScan& Telemetry::laser_scan_data() const {
  return laser_scan_data_ != NULL ? *laser_scan_data_ : *default_instance_->laser_scan_data_;
}
inline ::lunabotics::proto::Telemetry_LaserScan* Telemetry::mutable_laser_scan_data() {
  set_has_laser_scan_data();
  if (laser_scan_data_ == NULL) laser_scan_data_ = new ::lunabotics::proto::Telemetry_LaserScan;
  return laser_scan_data_;
}
inline ::lunabotics::proto::Telemetry_LaserScan* Telemetry::release_laser_scan_data() {
  clear_has_laser_scan_data();
  ::lunabotics::proto::Telemetry_LaserScan* temp = laser_scan_data_;
  laser_scan_data_ = NULL;
  return temp;
}
inline void Telemetry::set_allocated_laser_scan_data(::lunabotics::proto::Telemetry_LaserScan* laser_scan_data) {
  delete laser_scan_data_;
  laser_scan_data_ = laser_scan_data;
  if (laser_scan_data) {
    set_has_laser_scan_data();
  } else {
    clear_has_laser_scan_data();
  }
}

// optional .lunabotics.proto.AllWheelState all_wheel_state = 6;
inline bool Telemetry::has_all_wheel_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Telemetry::set_has_all_wheel_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Telemetry::clear_has_all_wheel_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Telemetry::clear_all_wheel_state() {
  if (all_wheel_state_ != NULL) all_wheel_state_->::lunabotics::proto::AllWheelState::Clear();
  clear_has_all_wheel_state();
}
inline const ::lunabotics::proto::AllWheelState& Telemetry::all_wheel_state() const {
  return all_wheel_state_ != NULL ? *all_wheel_state_ : *default_instance_->all_wheel_state_;
}
inline ::lunabotics::proto::AllWheelState* Telemetry::mutable_all_wheel_state() {
  set_has_all_wheel_state();
  if (all_wheel_state_ == NULL) all_wheel_state_ = new ::lunabotics::proto::AllWheelState;
  return all_wheel_state_;
}
inline ::lunabotics::proto::AllWheelState* Telemetry::release_all_wheel_state() {
  clear_has_all_wheel_state();
  ::lunabotics::proto::AllWheelState* temp = all_wheel_state_;
  all_wheel_state_ = NULL;
  return temp;
}
inline void Telemetry::set_allocated_all_wheel_state(::lunabotics::proto::AllWheelState* all_wheel_state) {
  delete all_wheel_state_;
  all_wheel_state_ = all_wheel_state;
  if (all_wheel_state) {
    set_has_all_wheel_state();
  } else {
    clear_has_all_wheel_state();
  }
}

// optional .lunabotics.proto.Telemetry.Geometry geometry_data = 7;
inline bool Telemetry::has_geometry_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Telemetry::set_has_geometry_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Telemetry::clear_has_geometry_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Telemetry::clear_geometry_data() {
  if (geometry_data_ != NULL) geometry_data_->::lunabotics::proto::Telemetry_Geometry::Clear();
  clear_has_geometry_data();
}
inline const ::lunabotics::proto::Telemetry_Geometry& Telemetry::geometry_data() const {
  return geometry_data_ != NULL ? *geometry_data_ : *default_instance_->geometry_data_;
}
inline ::lunabotics::proto::Telemetry_Geometry* Telemetry::mutable_geometry_data() {
  set_has_geometry_data();
  if (geometry_data_ == NULL) geometry_data_ = new ::lunabotics::proto::Telemetry_Geometry;
  return geometry_data_;
}
inline ::lunabotics::proto::Telemetry_Geometry* Telemetry::release_geometry_data() {
  clear_has_geometry_data();
  ::lunabotics::proto::Telemetry_Geometry* temp = geometry_data_;
  geometry_data_ = NULL;
  return temp;
}
inline void Telemetry::set_allocated_geometry_data(::lunabotics::proto::Telemetry_Geometry* geometry_data) {
  delete geometry_data_;
  geometry_data_ = geometry_data;
  if (geometry_data) {
    set_has_geometry_data();
  } else {
    clear_has_geometry_data();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace lunabotics

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lunabotics::proto::Telemetry_PointTurnState>() {
  return ::lunabotics::proto::Telemetry_PointTurnState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Telemetry_2eproto__INCLUDED
