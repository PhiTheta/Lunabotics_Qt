// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Telecommand.proto

#ifndef PROTOBUF_Telecommand_2eproto__INCLUDED
#define PROTOBUF_Telecommand_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "SteeringModeType.pb.h"
#include "Point.pb.h"
#include "AllWheelControl.pb.h"
// @@protoc_insertion_point(includes)

namespace lunabotics {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Telecommand_2eproto();
void protobuf_AssignDesc_Telecommand_2eproto();
void protobuf_ShutdownFile_Telecommand_2eproto();

class Telecommand;
class Telecommand_Teleoperation;
class Telecommand_Autonomy;
class Telecommand_SteeringMode;
class Telecommand_SteeringMode_AckermannSteeringData;
class Telecommand_SteeringMode_TurnInSpotSteeringData;
class Telecommand_SteeringMode_CrabSteeringData;
class Telecommand_DefineRoute;
class Telecommand_RequestMap;
class Telecommand_AdjustPID;

enum Telecommand_Type {
  Telecommand_Type_TELEOPERATION = 1,
  Telecommand_Type_SET_AUTONOMY = 2,
  Telecommand_Type_STEERING_MODE = 3,
  Telecommand_Type_DEFINE_ROUTE = 4,
  Telecommand_Type_REQUEST_MAP = 5,
  Telecommand_Type_ADJUST_PID = 6,
  Telecommand_Type_ADJUST_WHEELS = 7
};
bool Telecommand_Type_IsValid(int value);
const Telecommand_Type Telecommand_Type_Type_MIN = Telecommand_Type_TELEOPERATION;
const Telecommand_Type Telecommand_Type_Type_MAX = Telecommand_Type_ADJUST_WHEELS;
const int Telecommand_Type_Type_ARRAYSIZE = Telecommand_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Telecommand_Type_descriptor();
inline const ::std::string& Telecommand_Type_Name(Telecommand_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Telecommand_Type_descriptor(), value);
}
inline bool Telecommand_Type_Parse(
    const ::std::string& name, Telecommand_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Telecommand_Type>(
    Telecommand_Type_descriptor(), name, value);
}
// ===================================================================

class Telecommand_Teleoperation : public ::google::protobuf::Message {
 public:
  Telecommand_Teleoperation();
  virtual ~Telecommand_Teleoperation();

  Telecommand_Teleoperation(const Telecommand_Teleoperation& from);

  inline Telecommand_Teleoperation& operator=(const Telecommand_Teleoperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telecommand_Teleoperation& default_instance();

  void Swap(Telecommand_Teleoperation* other);

  // implements Message ----------------------------------------------

  Telecommand_Teleoperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telecommand_Teleoperation& from);
  void MergeFrom(const Telecommand_Teleoperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool forward = 1;
  inline bool has_forward() const;
  inline void clear_forward();
  static const int kForwardFieldNumber = 1;
  inline bool forward() const;
  inline void set_forward(bool value);

  // required bool backward = 2;
  inline bool has_backward() const;
  inline void clear_backward();
  static const int kBackwardFieldNumber = 2;
  inline bool backward() const;
  inline void set_backward(bool value);

  // required bool left = 3;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 3;
  inline bool left() const;
  inline void set_left(bool value);

  // required bool right = 4;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 4;
  inline bool right() const;
  inline void set_right(bool value);

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telecommand.Teleoperation)
 private:
  inline void set_has_forward();
  inline void clear_has_forward();
  inline void set_has_backward();
  inline void clear_has_backward();
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool forward_;
  bool backward_;
  bool left_;
  bool right_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Telecommand_2eproto();
  friend void protobuf_AssignDesc_Telecommand_2eproto();
  friend void protobuf_ShutdownFile_Telecommand_2eproto();

  void InitAsDefaultInstance();
  static Telecommand_Teleoperation* default_instance_;
};
// -------------------------------------------------------------------

class Telecommand_Autonomy : public ::google::protobuf::Message {
 public:
  Telecommand_Autonomy();
  virtual ~Telecommand_Autonomy();

  Telecommand_Autonomy(const Telecommand_Autonomy& from);

  inline Telecommand_Autonomy& operator=(const Telecommand_Autonomy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telecommand_Autonomy& default_instance();

  void Swap(Telecommand_Autonomy* other);

  // implements Message ----------------------------------------------

  Telecommand_Autonomy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telecommand_Autonomy& from);
  void MergeFrom(const Telecommand_Autonomy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool enabled = 1;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telecommand.Autonomy)
 private:
  inline void set_has_enabled();
  inline void clear_has_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Telecommand_2eproto();
  friend void protobuf_AssignDesc_Telecommand_2eproto();
  friend void protobuf_ShutdownFile_Telecommand_2eproto();

  void InitAsDefaultInstance();
  static Telecommand_Autonomy* default_instance_;
};
// -------------------------------------------------------------------

class Telecommand_SteeringMode_AckermannSteeringData : public ::google::protobuf::Message {
 public:
  Telecommand_SteeringMode_AckermannSteeringData();
  virtual ~Telecommand_SteeringMode_AckermannSteeringData();

  Telecommand_SteeringMode_AckermannSteeringData(const Telecommand_SteeringMode_AckermannSteeringData& from);

  inline Telecommand_SteeringMode_AckermannSteeringData& operator=(const Telecommand_SteeringMode_AckermannSteeringData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telecommand_SteeringMode_AckermannSteeringData& default_instance();

  void Swap(Telecommand_SteeringMode_AckermannSteeringData* other);

  // implements Message ----------------------------------------------

  Telecommand_SteeringMode_AckermannSteeringData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telecommand_SteeringMode_AckermannSteeringData& from);
  void MergeFrom(const Telecommand_SteeringMode_AckermannSteeringData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float max_linear_velocity = 1 [default = 0.33];
  inline bool has_max_linear_velocity() const;
  inline void clear_max_linear_velocity();
  static const int kMaxLinearVelocityFieldNumber = 1;
  inline float max_linear_velocity() const;
  inline void set_max_linear_velocity(float value);

  // optional int32 bezier_curve_segments = 2 [default = 20];
  inline bool has_bezier_curve_segments() const;
  inline void clear_bezier_curve_segments();
  static const int kBezierCurveSegmentsFieldNumber = 2;
  inline ::google::protobuf::int32 bezier_curve_segments() const;
  inline void set_bezier_curve_segments(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telecommand.SteeringMode.AckermannSteeringData)
 private:
  inline void set_has_max_linear_velocity();
  inline void clear_has_max_linear_velocity();
  inline void set_has_bezier_curve_segments();
  inline void clear_has_bezier_curve_segments();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float max_linear_velocity_;
  ::google::protobuf::int32 bezier_curve_segments_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Telecommand_2eproto();
  friend void protobuf_AssignDesc_Telecommand_2eproto();
  friend void protobuf_ShutdownFile_Telecommand_2eproto();

  void InitAsDefaultInstance();
  static Telecommand_SteeringMode_AckermannSteeringData* default_instance_;
};
// -------------------------------------------------------------------

class Telecommand_SteeringMode_TurnInSpotSteeringData : public ::google::protobuf::Message {
 public:
  Telecommand_SteeringMode_TurnInSpotSteeringData();
  virtual ~Telecommand_SteeringMode_TurnInSpotSteeringData();

  Telecommand_SteeringMode_TurnInSpotSteeringData(const Telecommand_SteeringMode_TurnInSpotSteeringData& from);

  inline Telecommand_SteeringMode_TurnInSpotSteeringData& operator=(const Telecommand_SteeringMode_TurnInSpotSteeringData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telecommand_SteeringMode_TurnInSpotSteeringData& default_instance();

  void Swap(Telecommand_SteeringMode_TurnInSpotSteeringData* other);

  // implements Message ----------------------------------------------

  Telecommand_SteeringMode_TurnInSpotSteeringData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telecommand_SteeringMode_TurnInSpotSteeringData& from);
  void MergeFrom(const Telecommand_SteeringMode_TurnInSpotSteeringData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telecommand.SteeringMode.TurnInSpotSteeringData)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_Telecommand_2eproto();
  friend void protobuf_AssignDesc_Telecommand_2eproto();
  friend void protobuf_ShutdownFile_Telecommand_2eproto();

  void InitAsDefaultInstance();
  static Telecommand_SteeringMode_TurnInSpotSteeringData* default_instance_;
};
// -------------------------------------------------------------------

class Telecommand_SteeringMode_CrabSteeringData : public ::google::protobuf::Message {
 public:
  Telecommand_SteeringMode_CrabSteeringData();
  virtual ~Telecommand_SteeringMode_CrabSteeringData();

  Telecommand_SteeringMode_CrabSteeringData(const Telecommand_SteeringMode_CrabSteeringData& from);

  inline Telecommand_SteeringMode_CrabSteeringData& operator=(const Telecommand_SteeringMode_CrabSteeringData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telecommand_SteeringMode_CrabSteeringData& default_instance();

  void Swap(Telecommand_SteeringMode_CrabSteeringData* other);

  // implements Message ----------------------------------------------

  Telecommand_SteeringMode_CrabSteeringData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telecommand_SteeringMode_CrabSteeringData& from);
  void MergeFrom(const Telecommand_SteeringMode_CrabSteeringData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telecommand.SteeringMode.CrabSteeringData)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_Telecommand_2eproto();
  friend void protobuf_AssignDesc_Telecommand_2eproto();
  friend void protobuf_ShutdownFile_Telecommand_2eproto();

  void InitAsDefaultInstance();
  static Telecommand_SteeringMode_CrabSteeringData* default_instance_;
};
// -------------------------------------------------------------------

class Telecommand_SteeringMode : public ::google::protobuf::Message {
 public:
  Telecommand_SteeringMode();
  virtual ~Telecommand_SteeringMode();

  Telecommand_SteeringMode(const Telecommand_SteeringMode& from);

  inline Telecommand_SteeringMode& operator=(const Telecommand_SteeringMode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telecommand_SteeringMode& default_instance();

  void Swap(Telecommand_SteeringMode* other);

  // implements Message ----------------------------------------------

  Telecommand_SteeringMode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telecommand_SteeringMode& from);
  void MergeFrom(const Telecommand_SteeringMode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Telecommand_SteeringMode_AckermannSteeringData AckermannSteeringData;
  typedef Telecommand_SteeringMode_TurnInSpotSteeringData TurnInSpotSteeringData;
  typedef Telecommand_SteeringMode_CrabSteeringData CrabSteeringData;

  // accessors -------------------------------------------------------

  // required .lunabotics.proto.SteeringModeType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::lunabotics::proto::SteeringModeType type() const;
  inline void set_type(::lunabotics::proto::SteeringModeType value);

  // optional .lunabotics.proto.Telecommand.SteeringMode.AckermannSteeringData ackermann_steering_data = 2;
  inline bool has_ackermann_steering_data() const;
  inline void clear_ackermann_steering_data();
  static const int kAckermannSteeringDataFieldNumber = 2;
  inline const ::lunabotics::proto::Telecommand_SteeringMode_AckermannSteeringData& ackermann_steering_data() const;
  inline ::lunabotics::proto::Telecommand_SteeringMode_AckermannSteeringData* mutable_ackermann_steering_data();
  inline ::lunabotics::proto::Telecommand_SteeringMode_AckermannSteeringData* release_ackermann_steering_data();
  inline void set_allocated_ackermann_steering_data(::lunabotics::proto::Telecommand_SteeringMode_AckermannSteeringData* ackermann_steering_data);

  // optional .lunabotics.proto.Telecommand.SteeringMode.TurnInSpotSteeringData turn_in_spot_steering_data = 3;
  inline bool has_turn_in_spot_steering_data() const;
  inline void clear_turn_in_spot_steering_data();
  static const int kTurnInSpotSteeringDataFieldNumber = 3;
  inline const ::lunabotics::proto::Telecommand_SteeringMode_TurnInSpotSteeringData& turn_in_spot_steering_data() const;
  inline ::lunabotics::proto::Telecommand_SteeringMode_TurnInSpotSteeringData* mutable_turn_in_spot_steering_data();
  inline ::lunabotics::proto::Telecommand_SteeringMode_TurnInSpotSteeringData* release_turn_in_spot_steering_data();
  inline void set_allocated_turn_in_spot_steering_data(::lunabotics::proto::Telecommand_SteeringMode_TurnInSpotSteeringData* turn_in_spot_steering_data);

  // optional .lunabotics.proto.Telecommand.SteeringMode.CrabSteeringData crab_steering_data = 4;
  inline bool has_crab_steering_data() const;
  inline void clear_crab_steering_data();
  static const int kCrabSteeringDataFieldNumber = 4;
  inline const ::lunabotics::proto::Telecommand_SteeringMode_CrabSteeringData& crab_steering_data() const;
  inline ::lunabotics::proto::Telecommand_SteeringMode_CrabSteeringData* mutable_crab_steering_data();
  inline ::lunabotics::proto::Telecommand_SteeringMode_CrabSteeringData* release_crab_steering_data();
  inline void set_allocated_crab_steering_data(::lunabotics::proto::Telecommand_SteeringMode_CrabSteeringData* crab_steering_data);

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telecommand.SteeringMode)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ackermann_steering_data();
  inline void clear_has_ackermann_steering_data();
  inline void set_has_turn_in_spot_steering_data();
  inline void clear_has_turn_in_spot_steering_data();
  inline void set_has_crab_steering_data();
  inline void clear_has_crab_steering_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::lunabotics::proto::Telecommand_SteeringMode_AckermannSteeringData* ackermann_steering_data_;
  ::lunabotics::proto::Telecommand_SteeringMode_TurnInSpotSteeringData* turn_in_spot_steering_data_;
  ::lunabotics::proto::Telecommand_SteeringMode_CrabSteeringData* crab_steering_data_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Telecommand_2eproto();
  friend void protobuf_AssignDesc_Telecommand_2eproto();
  friend void protobuf_ShutdownFile_Telecommand_2eproto();

  void InitAsDefaultInstance();
  static Telecommand_SteeringMode* default_instance_;
};
// -------------------------------------------------------------------

class Telecommand_DefineRoute : public ::google::protobuf::Message {
 public:
  Telecommand_DefineRoute();
  virtual ~Telecommand_DefineRoute();

  Telecommand_DefineRoute(const Telecommand_DefineRoute& from);

  inline Telecommand_DefineRoute& operator=(const Telecommand_DefineRoute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telecommand_DefineRoute& default_instance();

  void Swap(Telecommand_DefineRoute* other);

  // implements Message ----------------------------------------------

  Telecommand_DefineRoute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telecommand_DefineRoute& from);
  void MergeFrom(const Telecommand_DefineRoute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .lunabotics.proto.Point goal = 1;
  inline bool has_goal() const;
  inline void clear_goal();
  static const int kGoalFieldNumber = 1;
  inline const ::lunabotics::proto::Point& goal() const;
  inline ::lunabotics::proto::Point* mutable_goal();
  inline ::lunabotics::proto::Point* release_goal();
  inline void set_allocated_goal(::lunabotics::proto::Point* goal);

  // optional float heading_accuracy = 2 [default = 0.4];
  inline bool has_heading_accuracy() const;
  inline void clear_heading_accuracy();
  static const int kHeadingAccuracyFieldNumber = 2;
  inline float heading_accuracy() const;
  inline void set_heading_accuracy(float value);

  // optional float position_accuracy = 3 [default = 0.2];
  inline bool has_position_accuracy() const;
  inline void clear_position_accuracy();
  static const int kPositionAccuracyFieldNumber = 3;
  inline float position_accuracy() const;
  inline void set_position_accuracy(float value);

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telecommand.DefineRoute)
 private:
  inline void set_has_goal();
  inline void clear_has_goal();
  inline void set_has_heading_accuracy();
  inline void clear_has_heading_accuracy();
  inline void set_has_position_accuracy();
  inline void clear_has_position_accuracy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::lunabotics::proto::Point* goal_;
  float heading_accuracy_;
  float position_accuracy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Telecommand_2eproto();
  friend void protobuf_AssignDesc_Telecommand_2eproto();
  friend void protobuf_ShutdownFile_Telecommand_2eproto();

  void InitAsDefaultInstance();
  static Telecommand_DefineRoute* default_instance_;
};
// -------------------------------------------------------------------

class Telecommand_RequestMap : public ::google::protobuf::Message {
 public:
  Telecommand_RequestMap();
  virtual ~Telecommand_RequestMap();

  Telecommand_RequestMap(const Telecommand_RequestMap& from);

  inline Telecommand_RequestMap& operator=(const Telecommand_RequestMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telecommand_RequestMap& default_instance();

  void Swap(Telecommand_RequestMap* other);

  // implements Message ----------------------------------------------

  Telecommand_RequestMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telecommand_RequestMap& from);
  void MergeFrom(const Telecommand_RequestMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telecommand.RequestMap)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_Telecommand_2eproto();
  friend void protobuf_AssignDesc_Telecommand_2eproto();
  friend void protobuf_ShutdownFile_Telecommand_2eproto();

  void InitAsDefaultInstance();
  static Telecommand_RequestMap* default_instance_;
};
// -------------------------------------------------------------------

class Telecommand_AdjustPID : public ::google::protobuf::Message {
 public:
  Telecommand_AdjustPID();
  virtual ~Telecommand_AdjustPID();

  Telecommand_AdjustPID(const Telecommand_AdjustPID& from);

  inline Telecommand_AdjustPID& operator=(const Telecommand_AdjustPID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telecommand_AdjustPID& default_instance();

  void Swap(Telecommand_AdjustPID* other);

  // implements Message ----------------------------------------------

  Telecommand_AdjustPID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telecommand_AdjustPID& from);
  void MergeFrom(const Telecommand_AdjustPID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float p = 1;
  inline bool has_p() const;
  inline void clear_p();
  static const int kPFieldNumber = 1;
  inline float p() const;
  inline void set_p(float value);

  // required float i = 2;
  inline bool has_i() const;
  inline void clear_i();
  static const int kIFieldNumber = 2;
  inline float i() const;
  inline void set_i(float value);

  // required float d = 3;
  inline bool has_d() const;
  inline void clear_d();
  static const int kDFieldNumber = 3;
  inline float d() const;
  inline void set_d(float value);

  // required float velocity_offset = 4;
  inline bool has_velocity_offset() const;
  inline void clear_velocity_offset();
  static const int kVelocityOffsetFieldNumber = 4;
  inline float velocity_offset() const;
  inline void set_velocity_offset(float value);

  // required float velocity_multiplier = 5;
  inline bool has_velocity_multiplier() const;
  inline void clear_velocity_multiplier();
  static const int kVelocityMultiplierFieldNumber = 5;
  inline float velocity_multiplier() const;
  inline void set_velocity_multiplier(float value);

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telecommand.AdjustPID)
 private:
  inline void set_has_p();
  inline void clear_has_p();
  inline void set_has_i();
  inline void clear_has_i();
  inline void set_has_d();
  inline void clear_has_d();
  inline void set_has_velocity_offset();
  inline void clear_has_velocity_offset();
  inline void set_has_velocity_multiplier();
  inline void clear_has_velocity_multiplier();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float p_;
  float i_;
  float d_;
  float velocity_offset_;
  float velocity_multiplier_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Telecommand_2eproto();
  friend void protobuf_AssignDesc_Telecommand_2eproto();
  friend void protobuf_ShutdownFile_Telecommand_2eproto();

  void InitAsDefaultInstance();
  static Telecommand_AdjustPID* default_instance_;
};
// -------------------------------------------------------------------

class Telecommand : public ::google::protobuf::Message {
 public:
  Telecommand();
  virtual ~Telecommand();

  Telecommand(const Telecommand& from);

  inline Telecommand& operator=(const Telecommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telecommand& default_instance();

  void Swap(Telecommand* other);

  // implements Message ----------------------------------------------

  Telecommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telecommand& from);
  void MergeFrom(const Telecommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Telecommand_Teleoperation Teleoperation;
  typedef Telecommand_Autonomy Autonomy;
  typedef Telecommand_SteeringMode SteeringMode;
  typedef Telecommand_DefineRoute DefineRoute;
  typedef Telecommand_RequestMap RequestMap;
  typedef Telecommand_AdjustPID AdjustPID;

  typedef Telecommand_Type Type;
  static const Type TELEOPERATION = Telecommand_Type_TELEOPERATION;
  static const Type SET_AUTONOMY = Telecommand_Type_SET_AUTONOMY;
  static const Type STEERING_MODE = Telecommand_Type_STEERING_MODE;
  static const Type DEFINE_ROUTE = Telecommand_Type_DEFINE_ROUTE;
  static const Type REQUEST_MAP = Telecommand_Type_REQUEST_MAP;
  static const Type ADJUST_PID = Telecommand_Type_ADJUST_PID;
  static const Type ADJUST_WHEELS = Telecommand_Type_ADJUST_WHEELS;
  static inline bool Type_IsValid(int value) {
    return Telecommand_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Telecommand_Type_Type_MIN;
  static const Type Type_MAX =
    Telecommand_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Telecommand_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Telecommand_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Telecommand_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Telecommand_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .lunabotics.proto.Telecommand.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::lunabotics::proto::Telecommand_Type type() const;
  inline void set_type(::lunabotics::proto::Telecommand_Type value);

  // optional .lunabotics.proto.Telecommand.Teleoperation teleoperation_data = 2;
  inline bool has_teleoperation_data() const;
  inline void clear_teleoperation_data();
  static const int kTeleoperationDataFieldNumber = 2;
  inline const ::lunabotics::proto::Telecommand_Teleoperation& teleoperation_data() const;
  inline ::lunabotics::proto::Telecommand_Teleoperation* mutable_teleoperation_data();
  inline ::lunabotics::proto::Telecommand_Teleoperation* release_teleoperation_data();
  inline void set_allocated_teleoperation_data(::lunabotics::proto::Telecommand_Teleoperation* teleoperation_data);

  // optional .lunabotics.proto.Telecommand.Autonomy autonomy_data = 3;
  inline bool has_autonomy_data() const;
  inline void clear_autonomy_data();
  static const int kAutonomyDataFieldNumber = 3;
  inline const ::lunabotics::proto::Telecommand_Autonomy& autonomy_data() const;
  inline ::lunabotics::proto::Telecommand_Autonomy* mutable_autonomy_data();
  inline ::lunabotics::proto::Telecommand_Autonomy* release_autonomy_data();
  inline void set_allocated_autonomy_data(::lunabotics::proto::Telecommand_Autonomy* autonomy_data);

  // optional .lunabotics.proto.Telecommand.SteeringMode steering_mode_data = 4;
  inline bool has_steering_mode_data() const;
  inline void clear_steering_mode_data();
  static const int kSteeringModeDataFieldNumber = 4;
  inline const ::lunabotics::proto::Telecommand_SteeringMode& steering_mode_data() const;
  inline ::lunabotics::proto::Telecommand_SteeringMode* mutable_steering_mode_data();
  inline ::lunabotics::proto::Telecommand_SteeringMode* release_steering_mode_data();
  inline void set_allocated_steering_mode_data(::lunabotics::proto::Telecommand_SteeringMode* steering_mode_data);

  // optional .lunabotics.proto.Telecommand.DefineRoute define_route_data = 5;
  inline bool has_define_route_data() const;
  inline void clear_define_route_data();
  static const int kDefineRouteDataFieldNumber = 5;
  inline const ::lunabotics::proto::Telecommand_DefineRoute& define_route_data() const;
  inline ::lunabotics::proto::Telecommand_DefineRoute* mutable_define_route_data();
  inline ::lunabotics::proto::Telecommand_DefineRoute* release_define_route_data();
  inline void set_allocated_define_route_data(::lunabotics::proto::Telecommand_DefineRoute* define_route_data);

  // optional .lunabotics.proto.Telecommand.RequestMap request_map_data = 6;
  inline bool has_request_map_data() const;
  inline void clear_request_map_data();
  static const int kRequestMapDataFieldNumber = 6;
  inline const ::lunabotics::proto::Telecommand_RequestMap& request_map_data() const;
  inline ::lunabotics::proto::Telecommand_RequestMap* mutable_request_map_data();
  inline ::lunabotics::proto::Telecommand_RequestMap* release_request_map_data();
  inline void set_allocated_request_map_data(::lunabotics::proto::Telecommand_RequestMap* request_map_data);

  // optional .lunabotics.proto.Telecommand.AdjustPID adjust_pid_data = 7;
  inline bool has_adjust_pid_data() const;
  inline void clear_adjust_pid_data();
  static const int kAdjustPidDataFieldNumber = 7;
  inline const ::lunabotics::proto::Telecommand_AdjustPID& adjust_pid_data() const;
  inline ::lunabotics::proto::Telecommand_AdjustPID* mutable_adjust_pid_data();
  inline ::lunabotics::proto::Telecommand_AdjustPID* release_adjust_pid_data();
  inline void set_allocated_adjust_pid_data(::lunabotics::proto::Telecommand_AdjustPID* adjust_pid_data);

  // optional .lunabotics.proto.AllWheelControl all_wheel_control_data = 8;
  inline bool has_all_wheel_control_data() const;
  inline void clear_all_wheel_control_data();
  static const int kAllWheelControlDataFieldNumber = 8;
  inline const ::lunabotics::proto::AllWheelControl& all_wheel_control_data() const;
  inline ::lunabotics::proto::AllWheelControl* mutable_all_wheel_control_data();
  inline ::lunabotics::proto::AllWheelControl* release_all_wheel_control_data();
  inline void set_allocated_all_wheel_control_data(::lunabotics::proto::AllWheelControl* all_wheel_control_data);

  // @@protoc_insertion_point(class_scope:lunabotics.proto.Telecommand)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_teleoperation_data();
  inline void clear_has_teleoperation_data();
  inline void set_has_autonomy_data();
  inline void clear_has_autonomy_data();
  inline void set_has_steering_mode_data();
  inline void clear_has_steering_mode_data();
  inline void set_has_define_route_data();
  inline void clear_has_define_route_data();
  inline void set_has_request_map_data();
  inline void clear_has_request_map_data();
  inline void set_has_adjust_pid_data();
  inline void clear_has_adjust_pid_data();
  inline void set_has_all_wheel_control_data();
  inline void clear_has_all_wheel_control_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::lunabotics::proto::Telecommand_Teleoperation* teleoperation_data_;
  ::lunabotics::proto::Telecommand_Autonomy* autonomy_data_;
  ::lunabotics::proto::Telecommand_SteeringMode* steering_mode_data_;
  ::lunabotics::proto::Telecommand_DefineRoute* define_route_data_;
  ::lunabotics::proto::Telecommand_RequestMap* request_map_data_;
  ::lunabotics::proto::Telecommand_AdjustPID* adjust_pid_data_;
  ::lunabotics::proto::AllWheelControl* all_wheel_control_data_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_Telecommand_2eproto();
  friend void protobuf_AssignDesc_Telecommand_2eproto();
  friend void protobuf_ShutdownFile_Telecommand_2eproto();

  void InitAsDefaultInstance();
  static Telecommand* default_instance_;
};
// ===================================================================


// ===================================================================

// Telecommand_Teleoperation

// required bool forward = 1;
inline bool Telecommand_Teleoperation::has_forward() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telecommand_Teleoperation::set_has_forward() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telecommand_Teleoperation::clear_has_forward() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telecommand_Teleoperation::clear_forward() {
  forward_ = false;
  clear_has_forward();
}
inline bool Telecommand_Teleoperation::forward() const {
  return forward_;
}
inline void Telecommand_Teleoperation::set_forward(bool value) {
  set_has_forward();
  forward_ = value;
}

// required bool backward = 2;
inline bool Telecommand_Teleoperation::has_backward() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Telecommand_Teleoperation::set_has_backward() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Telecommand_Teleoperation::clear_has_backward() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Telecommand_Teleoperation::clear_backward() {
  backward_ = false;
  clear_has_backward();
}
inline bool Telecommand_Teleoperation::backward() const {
  return backward_;
}
inline void Telecommand_Teleoperation::set_backward(bool value) {
  set_has_backward();
  backward_ = value;
}

// required bool left = 3;
inline bool Telecommand_Teleoperation::has_left() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Telecommand_Teleoperation::set_has_left() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Telecommand_Teleoperation::clear_has_left() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Telecommand_Teleoperation::clear_left() {
  left_ = false;
  clear_has_left();
}
inline bool Telecommand_Teleoperation::left() const {
  return left_;
}
inline void Telecommand_Teleoperation::set_left(bool value) {
  set_has_left();
  left_ = value;
}

// required bool right = 4;
inline bool Telecommand_Teleoperation::has_right() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Telecommand_Teleoperation::set_has_right() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Telecommand_Teleoperation::clear_has_right() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Telecommand_Teleoperation::clear_right() {
  right_ = false;
  clear_has_right();
}
inline bool Telecommand_Teleoperation::right() const {
  return right_;
}
inline void Telecommand_Teleoperation::set_right(bool value) {
  set_has_right();
  right_ = value;
}

// -------------------------------------------------------------------

// Telecommand_Autonomy

// required bool enabled = 1;
inline bool Telecommand_Autonomy::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telecommand_Autonomy::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telecommand_Autonomy::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telecommand_Autonomy::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool Telecommand_Autonomy::enabled() const {
  return enabled_;
}
inline void Telecommand_Autonomy::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// -------------------------------------------------------------------

// Telecommand_SteeringMode_AckermannSteeringData

// optional float max_linear_velocity = 1 [default = 0.33];
inline bool Telecommand_SteeringMode_AckermannSteeringData::has_max_linear_velocity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telecommand_SteeringMode_AckermannSteeringData::set_has_max_linear_velocity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telecommand_SteeringMode_AckermannSteeringData::clear_has_max_linear_velocity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telecommand_SteeringMode_AckermannSteeringData::clear_max_linear_velocity() {
  max_linear_velocity_ = 0.33f;
  clear_has_max_linear_velocity();
}
inline float Telecommand_SteeringMode_AckermannSteeringData::max_linear_velocity() const {
  return max_linear_velocity_;
}
inline void Telecommand_SteeringMode_AckermannSteeringData::set_max_linear_velocity(float value) {
  set_has_max_linear_velocity();
  max_linear_velocity_ = value;
}

// optional int32 bezier_curve_segments = 2 [default = 20];
inline bool Telecommand_SteeringMode_AckermannSteeringData::has_bezier_curve_segments() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Telecommand_SteeringMode_AckermannSteeringData::set_has_bezier_curve_segments() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Telecommand_SteeringMode_AckermannSteeringData::clear_has_bezier_curve_segments() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Telecommand_SteeringMode_AckermannSteeringData::clear_bezier_curve_segments() {
  bezier_curve_segments_ = 20;
  clear_has_bezier_curve_segments();
}
inline ::google::protobuf::int32 Telecommand_SteeringMode_AckermannSteeringData::bezier_curve_segments() const {
  return bezier_curve_segments_;
}
inline void Telecommand_SteeringMode_AckermannSteeringData::set_bezier_curve_segments(::google::protobuf::int32 value) {
  set_has_bezier_curve_segments();
  bezier_curve_segments_ = value;
}

// -------------------------------------------------------------------

// Telecommand_SteeringMode_TurnInSpotSteeringData

// -------------------------------------------------------------------

// Telecommand_SteeringMode_CrabSteeringData

// -------------------------------------------------------------------

// Telecommand_SteeringMode

// required .lunabotics.proto.SteeringModeType type = 1;
inline bool Telecommand_SteeringMode::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telecommand_SteeringMode::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telecommand_SteeringMode::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telecommand_SteeringMode::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::lunabotics::proto::SteeringModeType Telecommand_SteeringMode::type() const {
  return static_cast< ::lunabotics::proto::SteeringModeType >(type_);
}
inline void Telecommand_SteeringMode::set_type(::lunabotics::proto::SteeringModeType value) {
  assert(::lunabotics::proto::SteeringModeType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .lunabotics.proto.Telecommand.SteeringMode.AckermannSteeringData ackermann_steering_data = 2;
inline bool Telecommand_SteeringMode::has_ackermann_steering_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Telecommand_SteeringMode::set_has_ackermann_steering_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Telecommand_SteeringMode::clear_has_ackermann_steering_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Telecommand_SteeringMode::clear_ackermann_steering_data() {
  if (ackermann_steering_data_ != NULL) ackermann_steering_data_->::lunabotics::proto::Telecommand_SteeringMode_AckermannSteeringData::Clear();
  clear_has_ackermann_steering_data();
}
inline const ::lunabotics::proto::Telecommand_SteeringMode_AckermannSteeringData& Telecommand_SteeringMode::ackermann_steering_data() const {
  return ackermann_steering_data_ != NULL ? *ackermann_steering_data_ : *default_instance_->ackermann_steering_data_;
}
inline ::lunabotics::proto::Telecommand_SteeringMode_AckermannSteeringData* Telecommand_SteeringMode::mutable_ackermann_steering_data() {
  set_has_ackermann_steering_data();
  if (ackermann_steering_data_ == NULL) ackermann_steering_data_ = new ::lunabotics::proto::Telecommand_SteeringMode_AckermannSteeringData;
  return ackermann_steering_data_;
}
inline ::lunabotics::proto::Telecommand_SteeringMode_AckermannSteeringData* Telecommand_SteeringMode::release_ackermann_steering_data() {
  clear_has_ackermann_steering_data();
  ::lunabotics::proto::Telecommand_SteeringMode_AckermannSteeringData* temp = ackermann_steering_data_;
  ackermann_steering_data_ = NULL;
  return temp;
}
inline void Telecommand_SteeringMode::set_allocated_ackermann_steering_data(::lunabotics::proto::Telecommand_SteeringMode_AckermannSteeringData* ackermann_steering_data) {
  delete ackermann_steering_data_;
  ackermann_steering_data_ = ackermann_steering_data;
  if (ackermann_steering_data) {
    set_has_ackermann_steering_data();
  } else {
    clear_has_ackermann_steering_data();
  }
}

// optional .lunabotics.proto.Telecommand.SteeringMode.TurnInSpotSteeringData turn_in_spot_steering_data = 3;
inline bool Telecommand_SteeringMode::has_turn_in_spot_steering_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Telecommand_SteeringMode::set_has_turn_in_spot_steering_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Telecommand_SteeringMode::clear_has_turn_in_spot_steering_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Telecommand_SteeringMode::clear_turn_in_spot_steering_data() {
  if (turn_in_spot_steering_data_ != NULL) turn_in_spot_steering_data_->::lunabotics::proto::Telecommand_SteeringMode_TurnInSpotSteeringData::Clear();
  clear_has_turn_in_spot_steering_data();
}
inline const ::lunabotics::proto::Telecommand_SteeringMode_TurnInSpotSteeringData& Telecommand_SteeringMode::turn_in_spot_steering_data() const {
  return turn_in_spot_steering_data_ != NULL ? *turn_in_spot_steering_data_ : *default_instance_->turn_in_spot_steering_data_;
}
inline ::lunabotics::proto::Telecommand_SteeringMode_TurnInSpotSteeringData* Telecommand_SteeringMode::mutable_turn_in_spot_steering_data() {
  set_has_turn_in_spot_steering_data();
  if (turn_in_spot_steering_data_ == NULL) turn_in_spot_steering_data_ = new ::lunabotics::proto::Telecommand_SteeringMode_TurnInSpotSteeringData;
  return turn_in_spot_steering_data_;
}
inline ::lunabotics::proto::Telecommand_SteeringMode_TurnInSpotSteeringData* Telecommand_SteeringMode::release_turn_in_spot_steering_data() {
  clear_has_turn_in_spot_steering_data();
  ::lunabotics::proto::Telecommand_SteeringMode_TurnInSpotSteeringData* temp = turn_in_spot_steering_data_;
  turn_in_spot_steering_data_ = NULL;
  return temp;
}
inline void Telecommand_SteeringMode::set_allocated_turn_in_spot_steering_data(::lunabotics::proto::Telecommand_SteeringMode_TurnInSpotSteeringData* turn_in_spot_steering_data) {
  delete turn_in_spot_steering_data_;
  turn_in_spot_steering_data_ = turn_in_spot_steering_data;
  if (turn_in_spot_steering_data) {
    set_has_turn_in_spot_steering_data();
  } else {
    clear_has_turn_in_spot_steering_data();
  }
}

// optional .lunabotics.proto.Telecommand.SteeringMode.CrabSteeringData crab_steering_data = 4;
inline bool Telecommand_SteeringMode::has_crab_steering_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Telecommand_SteeringMode::set_has_crab_steering_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Telecommand_SteeringMode::clear_has_crab_steering_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Telecommand_SteeringMode::clear_crab_steering_data() {
  if (crab_steering_data_ != NULL) crab_steering_data_->::lunabotics::proto::Telecommand_SteeringMode_CrabSteeringData::Clear();
  clear_has_crab_steering_data();
}
inline const ::lunabotics::proto::Telecommand_SteeringMode_CrabSteeringData& Telecommand_SteeringMode::crab_steering_data() const {
  return crab_steering_data_ != NULL ? *crab_steering_data_ : *default_instance_->crab_steering_data_;
}
inline ::lunabotics::proto::Telecommand_SteeringMode_CrabSteeringData* Telecommand_SteeringMode::mutable_crab_steering_data() {
  set_has_crab_steering_data();
  if (crab_steering_data_ == NULL) crab_steering_data_ = new ::lunabotics::proto::Telecommand_SteeringMode_CrabSteeringData;
  return crab_steering_data_;
}
inline ::lunabotics::proto::Telecommand_SteeringMode_CrabSteeringData* Telecommand_SteeringMode::release_crab_steering_data() {
  clear_has_crab_steering_data();
  ::lunabotics::proto::Telecommand_SteeringMode_CrabSteeringData* temp = crab_steering_data_;
  crab_steering_data_ = NULL;
  return temp;
}
inline void Telecommand_SteeringMode::set_allocated_crab_steering_data(::lunabotics::proto::Telecommand_SteeringMode_CrabSteeringData* crab_steering_data) {
  delete crab_steering_data_;
  crab_steering_data_ = crab_steering_data;
  if (crab_steering_data) {
    set_has_crab_steering_data();
  } else {
    clear_has_crab_steering_data();
  }
}

// -------------------------------------------------------------------

// Telecommand_DefineRoute

// required .lunabotics.proto.Point goal = 1;
inline bool Telecommand_DefineRoute::has_goal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telecommand_DefineRoute::set_has_goal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telecommand_DefineRoute::clear_has_goal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telecommand_DefineRoute::clear_goal() {
  if (goal_ != NULL) goal_->::lunabotics::proto::Point::Clear();
  clear_has_goal();
}
inline const ::lunabotics::proto::Point& Telecommand_DefineRoute::goal() const {
  return goal_ != NULL ? *goal_ : *default_instance_->goal_;
}
inline ::lunabotics::proto::Point* Telecommand_DefineRoute::mutable_goal() {
  set_has_goal();
  if (goal_ == NULL) goal_ = new ::lunabotics::proto::Point;
  return goal_;
}
inline ::lunabotics::proto::Point* Telecommand_DefineRoute::release_goal() {
  clear_has_goal();
  ::lunabotics::proto::Point* temp = goal_;
  goal_ = NULL;
  return temp;
}
inline void Telecommand_DefineRoute::set_allocated_goal(::lunabotics::proto::Point* goal) {
  delete goal_;
  goal_ = goal;
  if (goal) {
    set_has_goal();
  } else {
    clear_has_goal();
  }
}

// optional float heading_accuracy = 2 [default = 0.4];
inline bool Telecommand_DefineRoute::has_heading_accuracy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Telecommand_DefineRoute::set_has_heading_accuracy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Telecommand_DefineRoute::clear_has_heading_accuracy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Telecommand_DefineRoute::clear_heading_accuracy() {
  heading_accuracy_ = 0.4f;
  clear_has_heading_accuracy();
}
inline float Telecommand_DefineRoute::heading_accuracy() const {
  return heading_accuracy_;
}
inline void Telecommand_DefineRoute::set_heading_accuracy(float value) {
  set_has_heading_accuracy();
  heading_accuracy_ = value;
}

// optional float position_accuracy = 3 [default = 0.2];
inline bool Telecommand_DefineRoute::has_position_accuracy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Telecommand_DefineRoute::set_has_position_accuracy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Telecommand_DefineRoute::clear_has_position_accuracy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Telecommand_DefineRoute::clear_position_accuracy() {
  position_accuracy_ = 0.2f;
  clear_has_position_accuracy();
}
inline float Telecommand_DefineRoute::position_accuracy() const {
  return position_accuracy_;
}
inline void Telecommand_DefineRoute::set_position_accuracy(float value) {
  set_has_position_accuracy();
  position_accuracy_ = value;
}

// -------------------------------------------------------------------

// Telecommand_RequestMap

// -------------------------------------------------------------------

// Telecommand_AdjustPID

// required float p = 1;
inline bool Telecommand_AdjustPID::has_p() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telecommand_AdjustPID::set_has_p() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telecommand_AdjustPID::clear_has_p() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telecommand_AdjustPID::clear_p() {
  p_ = 0;
  clear_has_p();
}
inline float Telecommand_AdjustPID::p() const {
  return p_;
}
inline void Telecommand_AdjustPID::set_p(float value) {
  set_has_p();
  p_ = value;
}

// required float i = 2;
inline bool Telecommand_AdjustPID::has_i() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Telecommand_AdjustPID::set_has_i() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Telecommand_AdjustPID::clear_has_i() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Telecommand_AdjustPID::clear_i() {
  i_ = 0;
  clear_has_i();
}
inline float Telecommand_AdjustPID::i() const {
  return i_;
}
inline void Telecommand_AdjustPID::set_i(float value) {
  set_has_i();
  i_ = value;
}

// required float d = 3;
inline bool Telecommand_AdjustPID::has_d() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Telecommand_AdjustPID::set_has_d() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Telecommand_AdjustPID::clear_has_d() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Telecommand_AdjustPID::clear_d() {
  d_ = 0;
  clear_has_d();
}
inline float Telecommand_AdjustPID::d() const {
  return d_;
}
inline void Telecommand_AdjustPID::set_d(float value) {
  set_has_d();
  d_ = value;
}

// required float velocity_offset = 4;
inline bool Telecommand_AdjustPID::has_velocity_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Telecommand_AdjustPID::set_has_velocity_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Telecommand_AdjustPID::clear_has_velocity_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Telecommand_AdjustPID::clear_velocity_offset() {
  velocity_offset_ = 0;
  clear_has_velocity_offset();
}
inline float Telecommand_AdjustPID::velocity_offset() const {
  return velocity_offset_;
}
inline void Telecommand_AdjustPID::set_velocity_offset(float value) {
  set_has_velocity_offset();
  velocity_offset_ = value;
}

// required float velocity_multiplier = 5;
inline bool Telecommand_AdjustPID::has_velocity_multiplier() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Telecommand_AdjustPID::set_has_velocity_multiplier() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Telecommand_AdjustPID::clear_has_velocity_multiplier() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Telecommand_AdjustPID::clear_velocity_multiplier() {
  velocity_multiplier_ = 0;
  clear_has_velocity_multiplier();
}
inline float Telecommand_AdjustPID::velocity_multiplier() const {
  return velocity_multiplier_;
}
inline void Telecommand_AdjustPID::set_velocity_multiplier(float value) {
  set_has_velocity_multiplier();
  velocity_multiplier_ = value;
}

// -------------------------------------------------------------------

// Telecommand

// required .lunabotics.proto.Telecommand.Type type = 1;
inline bool Telecommand::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telecommand::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telecommand::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telecommand::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::lunabotics::proto::Telecommand_Type Telecommand::type() const {
  return static_cast< ::lunabotics::proto::Telecommand_Type >(type_);
}
inline void Telecommand::set_type(::lunabotics::proto::Telecommand_Type value) {
  assert(::lunabotics::proto::Telecommand_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .lunabotics.proto.Telecommand.Teleoperation teleoperation_data = 2;
inline bool Telecommand::has_teleoperation_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Telecommand::set_has_teleoperation_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Telecommand::clear_has_teleoperation_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Telecommand::clear_teleoperation_data() {
  if (teleoperation_data_ != NULL) teleoperation_data_->::lunabotics::proto::Telecommand_Teleoperation::Clear();
  clear_has_teleoperation_data();
}
inline const ::lunabotics::proto::Telecommand_Teleoperation& Telecommand::teleoperation_data() const {
  return teleoperation_data_ != NULL ? *teleoperation_data_ : *default_instance_->teleoperation_data_;
}
inline ::lunabotics::proto::Telecommand_Teleoperation* Telecommand::mutable_teleoperation_data() {
  set_has_teleoperation_data();
  if (teleoperation_data_ == NULL) teleoperation_data_ = new ::lunabotics::proto::Telecommand_Teleoperation;
  return teleoperation_data_;
}
inline ::lunabotics::proto::Telecommand_Teleoperation* Telecommand::release_teleoperation_data() {
  clear_has_teleoperation_data();
  ::lunabotics::proto::Telecommand_Teleoperation* temp = teleoperation_data_;
  teleoperation_data_ = NULL;
  return temp;
}
inline void Telecommand::set_allocated_teleoperation_data(::lunabotics::proto::Telecommand_Teleoperation* teleoperation_data) {
  delete teleoperation_data_;
  teleoperation_data_ = teleoperation_data;
  if (teleoperation_data) {
    set_has_teleoperation_data();
  } else {
    clear_has_teleoperation_data();
  }
}

// optional .lunabotics.proto.Telecommand.Autonomy autonomy_data = 3;
inline bool Telecommand::has_autonomy_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Telecommand::set_has_autonomy_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Telecommand::clear_has_autonomy_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Telecommand::clear_autonomy_data() {
  if (autonomy_data_ != NULL) autonomy_data_->::lunabotics::proto::Telecommand_Autonomy::Clear();
  clear_has_autonomy_data();
}
inline const ::lunabotics::proto::Telecommand_Autonomy& Telecommand::autonomy_data() const {
  return autonomy_data_ != NULL ? *autonomy_data_ : *default_instance_->autonomy_data_;
}
inline ::lunabotics::proto::Telecommand_Autonomy* Telecommand::mutable_autonomy_data() {
  set_has_autonomy_data();
  if (autonomy_data_ == NULL) autonomy_data_ = new ::lunabotics::proto::Telecommand_Autonomy;
  return autonomy_data_;
}
inline ::lunabotics::proto::Telecommand_Autonomy* Telecommand::release_autonomy_data() {
  clear_has_autonomy_data();
  ::lunabotics::proto::Telecommand_Autonomy* temp = autonomy_data_;
  autonomy_data_ = NULL;
  return temp;
}
inline void Telecommand::set_allocated_autonomy_data(::lunabotics::proto::Telecommand_Autonomy* autonomy_data) {
  delete autonomy_data_;
  autonomy_data_ = autonomy_data;
  if (autonomy_data) {
    set_has_autonomy_data();
  } else {
    clear_has_autonomy_data();
  }
}

// optional .lunabotics.proto.Telecommand.SteeringMode steering_mode_data = 4;
inline bool Telecommand::has_steering_mode_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Telecommand::set_has_steering_mode_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Telecommand::clear_has_steering_mode_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Telecommand::clear_steering_mode_data() {
  if (steering_mode_data_ != NULL) steering_mode_data_->::lunabotics::proto::Telecommand_SteeringMode::Clear();
  clear_has_steering_mode_data();
}
inline const ::lunabotics::proto::Telecommand_SteeringMode& Telecommand::steering_mode_data() const {
  return steering_mode_data_ != NULL ? *steering_mode_data_ : *default_instance_->steering_mode_data_;
}
inline ::lunabotics::proto::Telecommand_SteeringMode* Telecommand::mutable_steering_mode_data() {
  set_has_steering_mode_data();
  if (steering_mode_data_ == NULL) steering_mode_data_ = new ::lunabotics::proto::Telecommand_SteeringMode;
  return steering_mode_data_;
}
inline ::lunabotics::proto::Telecommand_SteeringMode* Telecommand::release_steering_mode_data() {
  clear_has_steering_mode_data();
  ::lunabotics::proto::Telecommand_SteeringMode* temp = steering_mode_data_;
  steering_mode_data_ = NULL;
  return temp;
}
inline void Telecommand::set_allocated_steering_mode_data(::lunabotics::proto::Telecommand_SteeringMode* steering_mode_data) {
  delete steering_mode_data_;
  steering_mode_data_ = steering_mode_data;
  if (steering_mode_data) {
    set_has_steering_mode_data();
  } else {
    clear_has_steering_mode_data();
  }
}

// optional .lunabotics.proto.Telecommand.DefineRoute define_route_data = 5;
inline bool Telecommand::has_define_route_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Telecommand::set_has_define_route_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Telecommand::clear_has_define_route_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Telecommand::clear_define_route_data() {
  if (define_route_data_ != NULL) define_route_data_->::lunabotics::proto::Telecommand_DefineRoute::Clear();
  clear_has_define_route_data();
}
inline const ::lunabotics::proto::Telecommand_DefineRoute& Telecommand::define_route_data() const {
  return define_route_data_ != NULL ? *define_route_data_ : *default_instance_->define_route_data_;
}
inline ::lunabotics::proto::Telecommand_DefineRoute* Telecommand::mutable_define_route_data() {
  set_has_define_route_data();
  if (define_route_data_ == NULL) define_route_data_ = new ::lunabotics::proto::Telecommand_DefineRoute;
  return define_route_data_;
}
inline ::lunabotics::proto::Telecommand_DefineRoute* Telecommand::release_define_route_data() {
  clear_has_define_route_data();
  ::lunabotics::proto::Telecommand_DefineRoute* temp = define_route_data_;
  define_route_data_ = NULL;
  return temp;
}
inline void Telecommand::set_allocated_define_route_data(::lunabotics::proto::Telecommand_DefineRoute* define_route_data) {
  delete define_route_data_;
  define_route_data_ = define_route_data;
  if (define_route_data) {
    set_has_define_route_data();
  } else {
    clear_has_define_route_data();
  }
}

// optional .lunabotics.proto.Telecommand.RequestMap request_map_data = 6;
inline bool Telecommand::has_request_map_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Telecommand::set_has_request_map_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Telecommand::clear_has_request_map_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Telecommand::clear_request_map_data() {
  if (request_map_data_ != NULL) request_map_data_->::lunabotics::proto::Telecommand_RequestMap::Clear();
  clear_has_request_map_data();
}
inline const ::lunabotics::proto::Telecommand_RequestMap& Telecommand::request_map_data() const {
  return request_map_data_ != NULL ? *request_map_data_ : *default_instance_->request_map_data_;
}
inline ::lunabotics::proto::Telecommand_RequestMap* Telecommand::mutable_request_map_data() {
  set_has_request_map_data();
  if (request_map_data_ == NULL) request_map_data_ = new ::lunabotics::proto::Telecommand_RequestMap;
  return request_map_data_;
}
inline ::lunabotics::proto::Telecommand_RequestMap* Telecommand::release_request_map_data() {
  clear_has_request_map_data();
  ::lunabotics::proto::Telecommand_RequestMap* temp = request_map_data_;
  request_map_data_ = NULL;
  return temp;
}
inline void Telecommand::set_allocated_request_map_data(::lunabotics::proto::Telecommand_RequestMap* request_map_data) {
  delete request_map_data_;
  request_map_data_ = request_map_data;
  if (request_map_data) {
    set_has_request_map_data();
  } else {
    clear_has_request_map_data();
  }
}

// optional .lunabotics.proto.Telecommand.AdjustPID adjust_pid_data = 7;
inline bool Telecommand::has_adjust_pid_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Telecommand::set_has_adjust_pid_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Telecommand::clear_has_adjust_pid_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Telecommand::clear_adjust_pid_data() {
  if (adjust_pid_data_ != NULL) adjust_pid_data_->::lunabotics::proto::Telecommand_AdjustPID::Clear();
  clear_has_adjust_pid_data();
}
inline const ::lunabotics::proto::Telecommand_AdjustPID& Telecommand::adjust_pid_data() const {
  return adjust_pid_data_ != NULL ? *adjust_pid_data_ : *default_instance_->adjust_pid_data_;
}
inline ::lunabotics::proto::Telecommand_AdjustPID* Telecommand::mutable_adjust_pid_data() {
  set_has_adjust_pid_data();
  if (adjust_pid_data_ == NULL) adjust_pid_data_ = new ::lunabotics::proto::Telecommand_AdjustPID;
  return adjust_pid_data_;
}
inline ::lunabotics::proto::Telecommand_AdjustPID* Telecommand::release_adjust_pid_data() {
  clear_has_adjust_pid_data();
  ::lunabotics::proto::Telecommand_AdjustPID* temp = adjust_pid_data_;
  adjust_pid_data_ = NULL;
  return temp;
}
inline void Telecommand::set_allocated_adjust_pid_data(::lunabotics::proto::Telecommand_AdjustPID* adjust_pid_data) {
  delete adjust_pid_data_;
  adjust_pid_data_ = adjust_pid_data;
  if (adjust_pid_data) {
    set_has_adjust_pid_data();
  } else {
    clear_has_adjust_pid_data();
  }
}

// optional .lunabotics.proto.AllWheelControl all_wheel_control_data = 8;
inline bool Telecommand::has_all_wheel_control_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Telecommand::set_has_all_wheel_control_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Telecommand::clear_has_all_wheel_control_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Telecommand::clear_all_wheel_control_data() {
  if (all_wheel_control_data_ != NULL) all_wheel_control_data_->::lunabotics::proto::AllWheelControl::Clear();
  clear_has_all_wheel_control_data();
}
inline const ::lunabotics::proto::AllWheelControl& Telecommand::all_wheel_control_data() const {
  return all_wheel_control_data_ != NULL ? *all_wheel_control_data_ : *default_instance_->all_wheel_control_data_;
}
inline ::lunabotics::proto::AllWheelControl* Telecommand::mutable_all_wheel_control_data() {
  set_has_all_wheel_control_data();
  if (all_wheel_control_data_ == NULL) all_wheel_control_data_ = new ::lunabotics::proto::AllWheelControl;
  return all_wheel_control_data_;
}
inline ::lunabotics::proto::AllWheelControl* Telecommand::release_all_wheel_control_data() {
  clear_has_all_wheel_control_data();
  ::lunabotics::proto::AllWheelControl* temp = all_wheel_control_data_;
  all_wheel_control_data_ = NULL;
  return temp;
}
inline void Telecommand::set_allocated_all_wheel_control_data(::lunabotics::proto::AllWheelControl* all_wheel_control_data) {
  delete all_wheel_control_data_;
  all_wheel_control_data_ = all_wheel_control_data;
  if (all_wheel_control_data) {
    set_has_all_wheel_control_data();
  } else {
    clear_has_all_wheel_control_data();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace lunabotics

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lunabotics::proto::Telecommand_Type>() {
  return ::lunabotics::proto::Telecommand_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Telecommand_2eproto__INCLUDED
