// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Telecommand.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Telecommand.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace lunabotics {
namespace proto {

namespace {

const ::google::protobuf::Descriptor* Telecommand_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Telecommand_reflection_ = NULL;
const ::google::protobuf::Descriptor* Telecommand_Teleoperation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Telecommand_Teleoperation_reflection_ = NULL;
const ::google::protobuf::Descriptor* Telecommand_Autonomy_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Telecommand_Autonomy_reflection_ = NULL;
const ::google::protobuf::Descriptor* Telecommand_SteeringMode_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Telecommand_SteeringMode_reflection_ = NULL;
const ::google::protobuf::Descriptor* Telecommand_DefineRoute_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Telecommand_DefineRoute_reflection_ = NULL;
const ::google::protobuf::Descriptor* Telecommand_RequestMap_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Telecommand_RequestMap_reflection_ = NULL;
const ::google::protobuf::Descriptor* Telecommand_AdjustPID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Telecommand_AdjustPID_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Telecommand_Type_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_Telecommand_2eproto() {
  protobuf_AddDesc_Telecommand_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "Telecommand.proto");
  GOOGLE_CHECK(file != NULL);
  Telecommand_descriptor_ = file->message_type(0);
  static const int Telecommand_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, teleoperation_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, autonomy_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, steering_mode_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, define_route_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, request_map_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, adjust_pid_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, all_wheel_control_data_),
  };
  Telecommand_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Telecommand_descriptor_,
      Telecommand::default_instance_,
      Telecommand_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Telecommand));
  Telecommand_Teleoperation_descriptor_ = Telecommand_descriptor_->nested_type(0);
  static const int Telecommand_Teleoperation_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_Teleoperation, forward_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_Teleoperation, backward_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_Teleoperation, left_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_Teleoperation, right_),
  };
  Telecommand_Teleoperation_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Telecommand_Teleoperation_descriptor_,
      Telecommand_Teleoperation::default_instance_,
      Telecommand_Teleoperation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_Teleoperation, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_Teleoperation, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Telecommand_Teleoperation));
  Telecommand_Autonomy_descriptor_ = Telecommand_descriptor_->nested_type(1);
  static const int Telecommand_Autonomy_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_Autonomy, enabled_),
  };
  Telecommand_Autonomy_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Telecommand_Autonomy_descriptor_,
      Telecommand_Autonomy::default_instance_,
      Telecommand_Autonomy_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_Autonomy, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_Autonomy, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Telecommand_Autonomy));
  Telecommand_SteeringMode_descriptor_ = Telecommand_descriptor_->nested_type(2);
  static const int Telecommand_SteeringMode_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode, heading_accuracy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode, position_accuracy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode, max_linear_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode, bezier_curve_segments_),
  };
  Telecommand_SteeringMode_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Telecommand_SteeringMode_descriptor_,
      Telecommand_SteeringMode::default_instance_,
      Telecommand_SteeringMode_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_SteeringMode, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Telecommand_SteeringMode));
  Telecommand_DefineRoute_descriptor_ = Telecommand_descriptor_->nested_type(3);
  static const int Telecommand_DefineRoute_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_DefineRoute, waypoints_),
  };
  Telecommand_DefineRoute_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Telecommand_DefineRoute_descriptor_,
      Telecommand_DefineRoute::default_instance_,
      Telecommand_DefineRoute_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_DefineRoute, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_DefineRoute, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Telecommand_DefineRoute));
  Telecommand_RequestMap_descriptor_ = Telecommand_descriptor_->nested_type(4);
  static const int Telecommand_RequestMap_offsets_[1] = {
  };
  Telecommand_RequestMap_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Telecommand_RequestMap_descriptor_,
      Telecommand_RequestMap::default_instance_,
      Telecommand_RequestMap_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_RequestMap, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_RequestMap, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Telecommand_RequestMap));
  Telecommand_AdjustPID_descriptor_ = Telecommand_descriptor_->nested_type(5);
  static const int Telecommand_AdjustPID_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_AdjustPID, p_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_AdjustPID, i_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_AdjustPID, d_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_AdjustPID, feedback_min_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_AdjustPID, feedback_multiplier_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_AdjustPID, feedforward_min_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_AdjustPID, feedforward_fraction_),
  };
  Telecommand_AdjustPID_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Telecommand_AdjustPID_descriptor_,
      Telecommand_AdjustPID::default_instance_,
      Telecommand_AdjustPID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_AdjustPID, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Telecommand_AdjustPID, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Telecommand_AdjustPID));
  Telecommand_Type_descriptor_ = Telecommand_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_Telecommand_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Telecommand_descriptor_, &Telecommand::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Telecommand_Teleoperation_descriptor_, &Telecommand_Teleoperation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Telecommand_Autonomy_descriptor_, &Telecommand_Autonomy::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Telecommand_SteeringMode_descriptor_, &Telecommand_SteeringMode::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Telecommand_DefineRoute_descriptor_, &Telecommand_DefineRoute::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Telecommand_RequestMap_descriptor_, &Telecommand_RequestMap::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Telecommand_AdjustPID_descriptor_, &Telecommand_AdjustPID::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_Telecommand_2eproto() {
  delete Telecommand::default_instance_;
  delete Telecommand_reflection_;
  delete Telecommand_Teleoperation::default_instance_;
  delete Telecommand_Teleoperation_reflection_;
  delete Telecommand_Autonomy::default_instance_;
  delete Telecommand_Autonomy_reflection_;
  delete Telecommand_SteeringMode::default_instance_;
  delete Telecommand_SteeringMode_reflection_;
  delete Telecommand_DefineRoute::default_instance_;
  delete Telecommand_DefineRoute_reflection_;
  delete Telecommand_RequestMap::default_instance_;
  delete Telecommand_RequestMap_reflection_;
  delete Telecommand_AdjustPID::default_instance_;
  delete Telecommand_AdjustPID_reflection_;
}

void protobuf_AddDesc_Telecommand_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::lunabotics::proto::protobuf_AddDesc_SteeringModeType_2eproto();
  ::lunabotics::proto::protobuf_AddDesc_Point_2eproto();
  ::lunabotics::proto::protobuf_AddDesc_AllWheelControl_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\021Telecommand.proto\022\020lunabotics.proto\032\026S"
    "teeringModeType.proto\032\013Point.proto\032\025AllW"
    "heelControl.proto\"\267\t\n\013Telecommand\0220\n\004typ"
    "e\030\001 \002(\0162\".lunabotics.proto.Telecommand.T"
    "ype\022G\n\022teleoperation_data\030\002 \001(\0132+.lunabo"
    "tics.proto.Telecommand.Teleoperation\022=\n\r"
    "autonomy_data\030\003 \001(\0132&.lunabotics.proto.T"
    "elecommand.Autonomy\022F\n\022steering_mode_dat"
    "a\030\004 \001(\0132*.lunabotics.proto.Telecommand.S"
    "teeringMode\022D\n\021define_route_data\030\005 \001(\0132)"
    ".lunabotics.proto.Telecommand.DefineRout"
    "e\022B\n\020request_map_data\030\006 \001(\0132(.lunabotics"
    ".proto.Telecommand.RequestMap\022@\n\017adjust_"
    "pid_data\030\007 \001(\0132\'.lunabotics.proto.Teleco"
    "mmand.AdjustPID\022A\n\026all_wheel_control_dat"
    "a\030\010 \001(\0132!.lunabotics.proto.AllWheelContr"
    "ol\032O\n\rTeleoperation\022\017\n\007forward\030\001 \002(\010\022\020\n\010"
    "backward\030\002 \002(\010\022\014\n\004left\030\003 \002(\010\022\r\n\005right\030\004 "
    "\002(\010\032\033\n\010Autonomy\022\017\n\007enabled\030\001 \002(\010\032\261\001\n\014Ste"
    "eringMode\0220\n\004type\030\001 \002(\0162\".lunabotics.pro"
    "to.SteeringModeType\022\030\n\020heading_accuracy\030"
    "\002 \002(\002\022\031\n\021position_accuracy\030\003 \002(\002\022\033\n\023max_"
    "linear_velocity\030\004 \002(\002\022\035\n\025bezier_curve_se"
    "gments\030\005 \002(\005\0329\n\013DefineRoute\022*\n\twaypoints"
    "\030\001 \003(\0132\027.lunabotics.proto.Point\032\014\n\nReque"
    "stMap\032\244\001\n\tAdjustPID\022\t\n\001p\030\001 \002(\002\022\t\n\001i\030\002 \002("
    "\002\022\t\n\001d\030\003 \002(\002\022\033\n\023feedback_min_offset\030\004 \002("
    "\002\022\033\n\023feedback_multiplier\030\005 \002(\002\022\036\n\026feedfo"
    "rward_min_offset\030\006 \002(\002\022\034\n\024feedforward_fr"
    "action\030\007 \002(\002\"\204\001\n\004Type\022\021\n\rTELEOPERATION\020\001"
    "\022\020\n\014SET_AUTONOMY\020\002\022\021\n\rSTEERING_MODE\020\003\022\020\n"
    "\014DEFINE_ROUTE\020\004\022\017\n\013REQUEST_MAP\020\005\022\016\n\nADJU"
    "ST_PID\020\006\022\021\n\rADJUST_WHEELS\020\007", 1307);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "Telecommand.proto", &protobuf_RegisterTypes);
  Telecommand::default_instance_ = new Telecommand();
  Telecommand_Teleoperation::default_instance_ = new Telecommand_Teleoperation();
  Telecommand_Autonomy::default_instance_ = new Telecommand_Autonomy();
  Telecommand_SteeringMode::default_instance_ = new Telecommand_SteeringMode();
  Telecommand_DefineRoute::default_instance_ = new Telecommand_DefineRoute();
  Telecommand_RequestMap::default_instance_ = new Telecommand_RequestMap();
  Telecommand_AdjustPID::default_instance_ = new Telecommand_AdjustPID();
  Telecommand::default_instance_->InitAsDefaultInstance();
  Telecommand_Teleoperation::default_instance_->InitAsDefaultInstance();
  Telecommand_Autonomy::default_instance_->InitAsDefaultInstance();
  Telecommand_SteeringMode::default_instance_->InitAsDefaultInstance();
  Telecommand_DefineRoute::default_instance_->InitAsDefaultInstance();
  Telecommand_RequestMap::default_instance_->InitAsDefaultInstance();
  Telecommand_AdjustPID::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Telecommand_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Telecommand_2eproto {
  StaticDescriptorInitializer_Telecommand_2eproto() {
    protobuf_AddDesc_Telecommand_2eproto();
  }
} static_descriptor_initializer_Telecommand_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* Telecommand_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Telecommand_Type_descriptor_;
}
bool Telecommand_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Telecommand_Type Telecommand::TELEOPERATION;
const Telecommand_Type Telecommand::SET_AUTONOMY;
const Telecommand_Type Telecommand::STEERING_MODE;
const Telecommand_Type Telecommand::DEFINE_ROUTE;
const Telecommand_Type Telecommand::REQUEST_MAP;
const Telecommand_Type Telecommand::ADJUST_PID;
const Telecommand_Type Telecommand::ADJUST_WHEELS;
const Telecommand_Type Telecommand::Type_MIN;
const Telecommand_Type Telecommand::Type_MAX;
const int Telecommand::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Telecommand_Teleoperation::kForwardFieldNumber;
const int Telecommand_Teleoperation::kBackwardFieldNumber;
const int Telecommand_Teleoperation::kLeftFieldNumber;
const int Telecommand_Teleoperation::kRightFieldNumber;
#endif  // !_MSC_VER

Telecommand_Teleoperation::Telecommand_Teleoperation()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Telecommand_Teleoperation::InitAsDefaultInstance() {
}

Telecommand_Teleoperation::Telecommand_Teleoperation(const Telecommand_Teleoperation& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Telecommand_Teleoperation::SharedCtor() {
  _cached_size_ = 0;
  forward_ = false;
  backward_ = false;
  left_ = false;
  right_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Telecommand_Teleoperation::~Telecommand_Teleoperation() {
  SharedDtor();
}

void Telecommand_Teleoperation::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Telecommand_Teleoperation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Telecommand_Teleoperation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Telecommand_Teleoperation_descriptor_;
}

const Telecommand_Teleoperation& Telecommand_Teleoperation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Telecommand_2eproto();
  return *default_instance_;
}

Telecommand_Teleoperation* Telecommand_Teleoperation::default_instance_ = NULL;

Telecommand_Teleoperation* Telecommand_Teleoperation::New() const {
  return new Telecommand_Teleoperation;
}

void Telecommand_Teleoperation::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    forward_ = false;
    backward_ = false;
    left_ = false;
    right_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Telecommand_Teleoperation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool forward = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &forward_)));
          set_has_forward();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_backward;
        break;
      }

      // required bool backward = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_backward:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &backward_)));
          set_has_backward();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_left;
        break;
      }

      // required bool left = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_left:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &left_)));
          set_has_left();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_right;
        break;
      }

      // required bool right = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_right:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &right_)));
          set_has_right();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Telecommand_Teleoperation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool forward = 1;
  if (has_forward()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->forward(), output);
  }

  // required bool backward = 2;
  if (has_backward()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->backward(), output);
  }

  // required bool left = 3;
  if (has_left()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->left(), output);
  }

  // required bool right = 4;
  if (has_right()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->right(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Telecommand_Teleoperation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool forward = 1;
  if (has_forward()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->forward(), target);
  }

  // required bool backward = 2;
  if (has_backward()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->backward(), target);
  }

  // required bool left = 3;
  if (has_left()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->left(), target);
  }

  // required bool right = 4;
  if (has_right()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->right(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Telecommand_Teleoperation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool forward = 1;
    if (has_forward()) {
      total_size += 1 + 1;
    }

    // required bool backward = 2;
    if (has_backward()) {
      total_size += 1 + 1;
    }

    // required bool left = 3;
    if (has_left()) {
      total_size += 1 + 1;
    }

    // required bool right = 4;
    if (has_right()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Telecommand_Teleoperation::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Telecommand_Teleoperation* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Telecommand_Teleoperation*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Telecommand_Teleoperation::MergeFrom(const Telecommand_Teleoperation& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_forward()) {
      set_forward(from.forward());
    }
    if (from.has_backward()) {
      set_backward(from.backward());
    }
    if (from.has_left()) {
      set_left(from.left());
    }
    if (from.has_right()) {
      set_right(from.right());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Telecommand_Teleoperation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Telecommand_Teleoperation::CopyFrom(const Telecommand_Teleoperation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Telecommand_Teleoperation::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void Telecommand_Teleoperation::Swap(Telecommand_Teleoperation* other) {
  if (other != this) {
    std::swap(forward_, other->forward_);
    std::swap(backward_, other->backward_);
    std::swap(left_, other->left_);
    std::swap(right_, other->right_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Telecommand_Teleoperation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Telecommand_Teleoperation_descriptor_;
  metadata.reflection = Telecommand_Teleoperation_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Telecommand_Autonomy::kEnabledFieldNumber;
#endif  // !_MSC_VER

Telecommand_Autonomy::Telecommand_Autonomy()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Telecommand_Autonomy::InitAsDefaultInstance() {
}

Telecommand_Autonomy::Telecommand_Autonomy(const Telecommand_Autonomy& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Telecommand_Autonomy::SharedCtor() {
  _cached_size_ = 0;
  enabled_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Telecommand_Autonomy::~Telecommand_Autonomy() {
  SharedDtor();
}

void Telecommand_Autonomy::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Telecommand_Autonomy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Telecommand_Autonomy::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Telecommand_Autonomy_descriptor_;
}

const Telecommand_Autonomy& Telecommand_Autonomy::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Telecommand_2eproto();
  return *default_instance_;
}

Telecommand_Autonomy* Telecommand_Autonomy::default_instance_ = NULL;

Telecommand_Autonomy* Telecommand_Autonomy::New() const {
  return new Telecommand_Autonomy;
}

void Telecommand_Autonomy::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    enabled_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Telecommand_Autonomy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool enabled = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enabled_)));
          set_has_enabled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Telecommand_Autonomy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool enabled = 1;
  if (has_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->enabled(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Telecommand_Autonomy::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool enabled = 1;
  if (has_enabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->enabled(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Telecommand_Autonomy::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool enabled = 1;
    if (has_enabled()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Telecommand_Autonomy::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Telecommand_Autonomy* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Telecommand_Autonomy*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Telecommand_Autonomy::MergeFrom(const Telecommand_Autonomy& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_enabled()) {
      set_enabled(from.enabled());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Telecommand_Autonomy::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Telecommand_Autonomy::CopyFrom(const Telecommand_Autonomy& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Telecommand_Autonomy::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Telecommand_Autonomy::Swap(Telecommand_Autonomy* other) {
  if (other != this) {
    std::swap(enabled_, other->enabled_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Telecommand_Autonomy::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Telecommand_Autonomy_descriptor_;
  metadata.reflection = Telecommand_Autonomy_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Telecommand_SteeringMode::kTypeFieldNumber;
const int Telecommand_SteeringMode::kHeadingAccuracyFieldNumber;
const int Telecommand_SteeringMode::kPositionAccuracyFieldNumber;
const int Telecommand_SteeringMode::kMaxLinearVelocityFieldNumber;
const int Telecommand_SteeringMode::kBezierCurveSegmentsFieldNumber;
#endif  // !_MSC_VER

Telecommand_SteeringMode::Telecommand_SteeringMode()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Telecommand_SteeringMode::InitAsDefaultInstance() {
}

Telecommand_SteeringMode::Telecommand_SteeringMode(const Telecommand_SteeringMode& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Telecommand_SteeringMode::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  heading_accuracy_ = 0;
  position_accuracy_ = 0;
  max_linear_velocity_ = 0;
  bezier_curve_segments_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Telecommand_SteeringMode::~Telecommand_SteeringMode() {
  SharedDtor();
}

void Telecommand_SteeringMode::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Telecommand_SteeringMode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Telecommand_SteeringMode::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Telecommand_SteeringMode_descriptor_;
}

const Telecommand_SteeringMode& Telecommand_SteeringMode::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Telecommand_2eproto();
  return *default_instance_;
}

Telecommand_SteeringMode* Telecommand_SteeringMode::default_instance_ = NULL;

Telecommand_SteeringMode* Telecommand_SteeringMode::New() const {
  return new Telecommand_SteeringMode;
}

void Telecommand_SteeringMode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    heading_accuracy_ = 0;
    position_accuracy_ = 0;
    max_linear_velocity_ = 0;
    bezier_curve_segments_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Telecommand_SteeringMode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .lunabotics.proto.SteeringModeType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::lunabotics::proto::SteeringModeType_IsValid(value)) {
            set_type(static_cast< ::lunabotics::proto::SteeringModeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_heading_accuracy;
        break;
      }

      // required float heading_accuracy = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_heading_accuracy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &heading_accuracy_)));
          set_has_heading_accuracy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_position_accuracy;
        break;
      }

      // required float position_accuracy = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_position_accuracy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &position_accuracy_)));
          set_has_position_accuracy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_max_linear_velocity;
        break;
      }

      // required float max_linear_velocity = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_max_linear_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_linear_velocity_)));
          set_has_max_linear_velocity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_bezier_curve_segments;
        break;
      }

      // required int32 bezier_curve_segments = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bezier_curve_segments:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bezier_curve_segments_)));
          set_has_bezier_curve_segments();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Telecommand_SteeringMode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .lunabotics.proto.SteeringModeType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required float heading_accuracy = 2;
  if (has_heading_accuracy()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->heading_accuracy(), output);
  }

  // required float position_accuracy = 3;
  if (has_position_accuracy()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->position_accuracy(), output);
  }

  // required float max_linear_velocity = 4;
  if (has_max_linear_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->max_linear_velocity(), output);
  }

  // required int32 bezier_curve_segments = 5;
  if (has_bezier_curve_segments()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->bezier_curve_segments(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Telecommand_SteeringMode::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .lunabotics.proto.SteeringModeType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // required float heading_accuracy = 2;
  if (has_heading_accuracy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->heading_accuracy(), target);
  }

  // required float position_accuracy = 3;
  if (has_position_accuracy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->position_accuracy(), target);
  }

  // required float max_linear_velocity = 4;
  if (has_max_linear_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->max_linear_velocity(), target);
  }

  // required int32 bezier_curve_segments = 5;
  if (has_bezier_curve_segments()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->bezier_curve_segments(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Telecommand_SteeringMode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .lunabotics.proto.SteeringModeType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required float heading_accuracy = 2;
    if (has_heading_accuracy()) {
      total_size += 1 + 4;
    }

    // required float position_accuracy = 3;
    if (has_position_accuracy()) {
      total_size += 1 + 4;
    }

    // required float max_linear_velocity = 4;
    if (has_max_linear_velocity()) {
      total_size += 1 + 4;
    }

    // required int32 bezier_curve_segments = 5;
    if (has_bezier_curve_segments()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bezier_curve_segments());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Telecommand_SteeringMode::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Telecommand_SteeringMode* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Telecommand_SteeringMode*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Telecommand_SteeringMode::MergeFrom(const Telecommand_SteeringMode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_heading_accuracy()) {
      set_heading_accuracy(from.heading_accuracy());
    }
    if (from.has_position_accuracy()) {
      set_position_accuracy(from.position_accuracy());
    }
    if (from.has_max_linear_velocity()) {
      set_max_linear_velocity(from.max_linear_velocity());
    }
    if (from.has_bezier_curve_segments()) {
      set_bezier_curve_segments(from.bezier_curve_segments());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Telecommand_SteeringMode::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Telecommand_SteeringMode::CopyFrom(const Telecommand_SteeringMode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Telecommand_SteeringMode::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void Telecommand_SteeringMode::Swap(Telecommand_SteeringMode* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(heading_accuracy_, other->heading_accuracy_);
    std::swap(position_accuracy_, other->position_accuracy_);
    std::swap(max_linear_velocity_, other->max_linear_velocity_);
    std::swap(bezier_curve_segments_, other->bezier_curve_segments_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Telecommand_SteeringMode::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Telecommand_SteeringMode_descriptor_;
  metadata.reflection = Telecommand_SteeringMode_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Telecommand_DefineRoute::kWaypointsFieldNumber;
#endif  // !_MSC_VER

Telecommand_DefineRoute::Telecommand_DefineRoute()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Telecommand_DefineRoute::InitAsDefaultInstance() {
}

Telecommand_DefineRoute::Telecommand_DefineRoute(const Telecommand_DefineRoute& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Telecommand_DefineRoute::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Telecommand_DefineRoute::~Telecommand_DefineRoute() {
  SharedDtor();
}

void Telecommand_DefineRoute::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Telecommand_DefineRoute::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Telecommand_DefineRoute::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Telecommand_DefineRoute_descriptor_;
}

const Telecommand_DefineRoute& Telecommand_DefineRoute::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Telecommand_2eproto();
  return *default_instance_;
}

Telecommand_DefineRoute* Telecommand_DefineRoute::default_instance_ = NULL;

Telecommand_DefineRoute* Telecommand_DefineRoute::New() const {
  return new Telecommand_DefineRoute;
}

void Telecommand_DefineRoute::Clear() {
  waypoints_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Telecommand_DefineRoute::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .lunabotics.proto.Point waypoints = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_waypoints:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_waypoints()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_waypoints;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Telecommand_DefineRoute::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .lunabotics.proto.Point waypoints = 1;
  for (int i = 0; i < this->waypoints_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->waypoints(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Telecommand_DefineRoute::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .lunabotics.proto.Point waypoints = 1;
  for (int i = 0; i < this->waypoints_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->waypoints(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Telecommand_DefineRoute::ByteSize() const {
  int total_size = 0;

  // repeated .lunabotics.proto.Point waypoints = 1;
  total_size += 1 * this->waypoints_size();
  for (int i = 0; i < this->waypoints_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->waypoints(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Telecommand_DefineRoute::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Telecommand_DefineRoute* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Telecommand_DefineRoute*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Telecommand_DefineRoute::MergeFrom(const Telecommand_DefineRoute& from) {
  GOOGLE_CHECK_NE(&from, this);
  waypoints_.MergeFrom(from.waypoints_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Telecommand_DefineRoute::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Telecommand_DefineRoute::CopyFrom(const Telecommand_DefineRoute& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Telecommand_DefineRoute::IsInitialized() const {

  for (int i = 0; i < waypoints_size(); i++) {
    if (!this->waypoints(i).IsInitialized()) return false;
  }
  return true;
}

void Telecommand_DefineRoute::Swap(Telecommand_DefineRoute* other) {
  if (other != this) {
    waypoints_.Swap(&other->waypoints_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Telecommand_DefineRoute::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Telecommand_DefineRoute_descriptor_;
  metadata.reflection = Telecommand_DefineRoute_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

Telecommand_RequestMap::Telecommand_RequestMap()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Telecommand_RequestMap::InitAsDefaultInstance() {
}

Telecommand_RequestMap::Telecommand_RequestMap(const Telecommand_RequestMap& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Telecommand_RequestMap::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Telecommand_RequestMap::~Telecommand_RequestMap() {
  SharedDtor();
}

void Telecommand_RequestMap::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Telecommand_RequestMap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Telecommand_RequestMap::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Telecommand_RequestMap_descriptor_;
}

const Telecommand_RequestMap& Telecommand_RequestMap::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Telecommand_2eproto();
  return *default_instance_;
}

Telecommand_RequestMap* Telecommand_RequestMap::default_instance_ = NULL;

Telecommand_RequestMap* Telecommand_RequestMap::New() const {
  return new Telecommand_RequestMap;
}

void Telecommand_RequestMap::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Telecommand_RequestMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void Telecommand_RequestMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Telecommand_RequestMap::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Telecommand_RequestMap::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Telecommand_RequestMap::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Telecommand_RequestMap* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Telecommand_RequestMap*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Telecommand_RequestMap::MergeFrom(const Telecommand_RequestMap& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Telecommand_RequestMap::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Telecommand_RequestMap::CopyFrom(const Telecommand_RequestMap& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Telecommand_RequestMap::IsInitialized() const {

  return true;
}

void Telecommand_RequestMap::Swap(Telecommand_RequestMap* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Telecommand_RequestMap::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Telecommand_RequestMap_descriptor_;
  metadata.reflection = Telecommand_RequestMap_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Telecommand_AdjustPID::kPFieldNumber;
const int Telecommand_AdjustPID::kIFieldNumber;
const int Telecommand_AdjustPID::kDFieldNumber;
const int Telecommand_AdjustPID::kFeedbackMinOffsetFieldNumber;
const int Telecommand_AdjustPID::kFeedbackMultiplierFieldNumber;
const int Telecommand_AdjustPID::kFeedforwardMinOffsetFieldNumber;
const int Telecommand_AdjustPID::kFeedforwardFractionFieldNumber;
#endif  // !_MSC_VER

Telecommand_AdjustPID::Telecommand_AdjustPID()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Telecommand_AdjustPID::InitAsDefaultInstance() {
}

Telecommand_AdjustPID::Telecommand_AdjustPID(const Telecommand_AdjustPID& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Telecommand_AdjustPID::SharedCtor() {
  _cached_size_ = 0;
  p_ = 0;
  i_ = 0;
  d_ = 0;
  feedback_min_offset_ = 0;
  feedback_multiplier_ = 0;
  feedforward_min_offset_ = 0;
  feedforward_fraction_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Telecommand_AdjustPID::~Telecommand_AdjustPID() {
  SharedDtor();
}

void Telecommand_AdjustPID::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Telecommand_AdjustPID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Telecommand_AdjustPID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Telecommand_AdjustPID_descriptor_;
}

const Telecommand_AdjustPID& Telecommand_AdjustPID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Telecommand_2eproto();
  return *default_instance_;
}

Telecommand_AdjustPID* Telecommand_AdjustPID::default_instance_ = NULL;

Telecommand_AdjustPID* Telecommand_AdjustPID::New() const {
  return new Telecommand_AdjustPID;
}

void Telecommand_AdjustPID::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    p_ = 0;
    i_ = 0;
    d_ = 0;
    feedback_min_offset_ = 0;
    feedback_multiplier_ = 0;
    feedforward_min_offset_ = 0;
    feedforward_fraction_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Telecommand_AdjustPID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float p = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &p_)));
          set_has_p();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_i;
        break;
      }

      // required float i = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_i:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &i_)));
          set_has_i();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_d;
        break;
      }

      // required float d = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_d:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &d_)));
          set_has_d();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_feedback_min_offset;
        break;
      }

      // required float feedback_min_offset = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_feedback_min_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &feedback_min_offset_)));
          set_has_feedback_min_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_feedback_multiplier;
        break;
      }

      // required float feedback_multiplier = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_feedback_multiplier:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &feedback_multiplier_)));
          set_has_feedback_multiplier();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_feedforward_min_offset;
        break;
      }

      // required float feedforward_min_offset = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_feedforward_min_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &feedforward_min_offset_)));
          set_has_feedforward_min_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_feedforward_fraction;
        break;
      }

      // required float feedforward_fraction = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_feedforward_fraction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &feedforward_fraction_)));
          set_has_feedforward_fraction();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Telecommand_AdjustPID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float p = 1;
  if (has_p()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->p(), output);
  }

  // required float i = 2;
  if (has_i()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->i(), output);
  }

  // required float d = 3;
  if (has_d()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->d(), output);
  }

  // required float feedback_min_offset = 4;
  if (has_feedback_min_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->feedback_min_offset(), output);
  }

  // required float feedback_multiplier = 5;
  if (has_feedback_multiplier()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->feedback_multiplier(), output);
  }

  // required float feedforward_min_offset = 6;
  if (has_feedforward_min_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->feedforward_min_offset(), output);
  }

  // required float feedforward_fraction = 7;
  if (has_feedforward_fraction()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->feedforward_fraction(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Telecommand_AdjustPID::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float p = 1;
  if (has_p()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->p(), target);
  }

  // required float i = 2;
  if (has_i()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->i(), target);
  }

  // required float d = 3;
  if (has_d()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->d(), target);
  }

  // required float feedback_min_offset = 4;
  if (has_feedback_min_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->feedback_min_offset(), target);
  }

  // required float feedback_multiplier = 5;
  if (has_feedback_multiplier()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->feedback_multiplier(), target);
  }

  // required float feedforward_min_offset = 6;
  if (has_feedforward_min_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->feedforward_min_offset(), target);
  }

  // required float feedforward_fraction = 7;
  if (has_feedforward_fraction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->feedforward_fraction(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Telecommand_AdjustPID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float p = 1;
    if (has_p()) {
      total_size += 1 + 4;
    }

    // required float i = 2;
    if (has_i()) {
      total_size += 1 + 4;
    }

    // required float d = 3;
    if (has_d()) {
      total_size += 1 + 4;
    }

    // required float feedback_min_offset = 4;
    if (has_feedback_min_offset()) {
      total_size += 1 + 4;
    }

    // required float feedback_multiplier = 5;
    if (has_feedback_multiplier()) {
      total_size += 1 + 4;
    }

    // required float feedforward_min_offset = 6;
    if (has_feedforward_min_offset()) {
      total_size += 1 + 4;
    }

    // required float feedforward_fraction = 7;
    if (has_feedforward_fraction()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Telecommand_AdjustPID::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Telecommand_AdjustPID* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Telecommand_AdjustPID*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Telecommand_AdjustPID::MergeFrom(const Telecommand_AdjustPID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_p()) {
      set_p(from.p());
    }
    if (from.has_i()) {
      set_i(from.i());
    }
    if (from.has_d()) {
      set_d(from.d());
    }
    if (from.has_feedback_min_offset()) {
      set_feedback_min_offset(from.feedback_min_offset());
    }
    if (from.has_feedback_multiplier()) {
      set_feedback_multiplier(from.feedback_multiplier());
    }
    if (from.has_feedforward_min_offset()) {
      set_feedforward_min_offset(from.feedforward_min_offset());
    }
    if (from.has_feedforward_fraction()) {
      set_feedforward_fraction(from.feedforward_fraction());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Telecommand_AdjustPID::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Telecommand_AdjustPID::CopyFrom(const Telecommand_AdjustPID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Telecommand_AdjustPID::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void Telecommand_AdjustPID::Swap(Telecommand_AdjustPID* other) {
  if (other != this) {
    std::swap(p_, other->p_);
    std::swap(i_, other->i_);
    std::swap(d_, other->d_);
    std::swap(feedback_min_offset_, other->feedback_min_offset_);
    std::swap(feedback_multiplier_, other->feedback_multiplier_);
    std::swap(feedforward_min_offset_, other->feedforward_min_offset_);
    std::swap(feedforward_fraction_, other->feedforward_fraction_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Telecommand_AdjustPID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Telecommand_AdjustPID_descriptor_;
  metadata.reflection = Telecommand_AdjustPID_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Telecommand::kTypeFieldNumber;
const int Telecommand::kTeleoperationDataFieldNumber;
const int Telecommand::kAutonomyDataFieldNumber;
const int Telecommand::kSteeringModeDataFieldNumber;
const int Telecommand::kDefineRouteDataFieldNumber;
const int Telecommand::kRequestMapDataFieldNumber;
const int Telecommand::kAdjustPidDataFieldNumber;
const int Telecommand::kAllWheelControlDataFieldNumber;
#endif  // !_MSC_VER

Telecommand::Telecommand()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Telecommand::InitAsDefaultInstance() {
  teleoperation_data_ = const_cast< ::lunabotics::proto::Telecommand_Teleoperation*>(&::lunabotics::proto::Telecommand_Teleoperation::default_instance());
  autonomy_data_ = const_cast< ::lunabotics::proto::Telecommand_Autonomy*>(&::lunabotics::proto::Telecommand_Autonomy::default_instance());
  steering_mode_data_ = const_cast< ::lunabotics::proto::Telecommand_SteeringMode*>(&::lunabotics::proto::Telecommand_SteeringMode::default_instance());
  define_route_data_ = const_cast< ::lunabotics::proto::Telecommand_DefineRoute*>(&::lunabotics::proto::Telecommand_DefineRoute::default_instance());
  request_map_data_ = const_cast< ::lunabotics::proto::Telecommand_RequestMap*>(&::lunabotics::proto::Telecommand_RequestMap::default_instance());
  adjust_pid_data_ = const_cast< ::lunabotics::proto::Telecommand_AdjustPID*>(&::lunabotics::proto::Telecommand_AdjustPID::default_instance());
  all_wheel_control_data_ = const_cast< ::lunabotics::proto::AllWheelControl*>(&::lunabotics::proto::AllWheelControl::default_instance());
}

Telecommand::Telecommand(const Telecommand& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Telecommand::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  teleoperation_data_ = NULL;
  autonomy_data_ = NULL;
  steering_mode_data_ = NULL;
  define_route_data_ = NULL;
  request_map_data_ = NULL;
  adjust_pid_data_ = NULL;
  all_wheel_control_data_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Telecommand::~Telecommand() {
  SharedDtor();
}

void Telecommand::SharedDtor() {
  if (this != default_instance_) {
    delete teleoperation_data_;
    delete autonomy_data_;
    delete steering_mode_data_;
    delete define_route_data_;
    delete request_map_data_;
    delete adjust_pid_data_;
    delete all_wheel_control_data_;
  }
}

void Telecommand::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Telecommand::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Telecommand_descriptor_;
}

const Telecommand& Telecommand::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Telecommand_2eproto();
  return *default_instance_;
}

Telecommand* Telecommand::default_instance_ = NULL;

Telecommand* Telecommand::New() const {
  return new Telecommand;
}

void Telecommand::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_teleoperation_data()) {
      if (teleoperation_data_ != NULL) teleoperation_data_->::lunabotics::proto::Telecommand_Teleoperation::Clear();
    }
    if (has_autonomy_data()) {
      if (autonomy_data_ != NULL) autonomy_data_->::lunabotics::proto::Telecommand_Autonomy::Clear();
    }
    if (has_steering_mode_data()) {
      if (steering_mode_data_ != NULL) steering_mode_data_->::lunabotics::proto::Telecommand_SteeringMode::Clear();
    }
    if (has_define_route_data()) {
      if (define_route_data_ != NULL) define_route_data_->::lunabotics::proto::Telecommand_DefineRoute::Clear();
    }
    if (has_request_map_data()) {
      if (request_map_data_ != NULL) request_map_data_->::lunabotics::proto::Telecommand_RequestMap::Clear();
    }
    if (has_adjust_pid_data()) {
      if (adjust_pid_data_ != NULL) adjust_pid_data_->::lunabotics::proto::Telecommand_AdjustPID::Clear();
    }
    if (has_all_wheel_control_data()) {
      if (all_wheel_control_data_ != NULL) all_wheel_control_data_->::lunabotics::proto::AllWheelControl::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Telecommand::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .lunabotics.proto.Telecommand.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::lunabotics::proto::Telecommand_Type_IsValid(value)) {
            set_type(static_cast< ::lunabotics::proto::Telecommand_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_teleoperation_data;
        break;
      }

      // optional .lunabotics.proto.Telecommand.Teleoperation teleoperation_data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_teleoperation_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_teleoperation_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_autonomy_data;
        break;
      }

      // optional .lunabotics.proto.Telecommand.Autonomy autonomy_data = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_autonomy_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_autonomy_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_steering_mode_data;
        break;
      }

      // optional .lunabotics.proto.Telecommand.SteeringMode steering_mode_data = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_steering_mode_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_steering_mode_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_define_route_data;
        break;
      }

      // optional .lunabotics.proto.Telecommand.DefineRoute define_route_data = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_define_route_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_define_route_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_request_map_data;
        break;
      }

      // optional .lunabotics.proto.Telecommand.RequestMap request_map_data = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_request_map_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_request_map_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_adjust_pid_data;
        break;
      }

      // optional .lunabotics.proto.Telecommand.AdjustPID adjust_pid_data = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_adjust_pid_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_adjust_pid_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_all_wheel_control_data;
        break;
      }

      // optional .lunabotics.proto.AllWheelControl all_wheel_control_data = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_all_wheel_control_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_all_wheel_control_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Telecommand::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .lunabotics.proto.Telecommand.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .lunabotics.proto.Telecommand.Teleoperation teleoperation_data = 2;
  if (has_teleoperation_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->teleoperation_data(), output);
  }

  // optional .lunabotics.proto.Telecommand.Autonomy autonomy_data = 3;
  if (has_autonomy_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->autonomy_data(), output);
  }

  // optional .lunabotics.proto.Telecommand.SteeringMode steering_mode_data = 4;
  if (has_steering_mode_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->steering_mode_data(), output);
  }

  // optional .lunabotics.proto.Telecommand.DefineRoute define_route_data = 5;
  if (has_define_route_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->define_route_data(), output);
  }

  // optional .lunabotics.proto.Telecommand.RequestMap request_map_data = 6;
  if (has_request_map_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->request_map_data(), output);
  }

  // optional .lunabotics.proto.Telecommand.AdjustPID adjust_pid_data = 7;
  if (has_adjust_pid_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->adjust_pid_data(), output);
  }

  // optional .lunabotics.proto.AllWheelControl all_wheel_control_data = 8;
  if (has_all_wheel_control_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->all_wheel_control_data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Telecommand::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .lunabotics.proto.Telecommand.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .lunabotics.proto.Telecommand.Teleoperation teleoperation_data = 2;
  if (has_teleoperation_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->teleoperation_data(), target);
  }

  // optional .lunabotics.proto.Telecommand.Autonomy autonomy_data = 3;
  if (has_autonomy_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->autonomy_data(), target);
  }

  // optional .lunabotics.proto.Telecommand.SteeringMode steering_mode_data = 4;
  if (has_steering_mode_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->steering_mode_data(), target);
  }

  // optional .lunabotics.proto.Telecommand.DefineRoute define_route_data = 5;
  if (has_define_route_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->define_route_data(), target);
  }

  // optional .lunabotics.proto.Telecommand.RequestMap request_map_data = 6;
  if (has_request_map_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->request_map_data(), target);
  }

  // optional .lunabotics.proto.Telecommand.AdjustPID adjust_pid_data = 7;
  if (has_adjust_pid_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->adjust_pid_data(), target);
  }

  // optional .lunabotics.proto.AllWheelControl all_wheel_control_data = 8;
  if (has_all_wheel_control_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->all_wheel_control_data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Telecommand::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .lunabotics.proto.Telecommand.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .lunabotics.proto.Telecommand.Teleoperation teleoperation_data = 2;
    if (has_teleoperation_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->teleoperation_data());
    }

    // optional .lunabotics.proto.Telecommand.Autonomy autonomy_data = 3;
    if (has_autonomy_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->autonomy_data());
    }

    // optional .lunabotics.proto.Telecommand.SteeringMode steering_mode_data = 4;
    if (has_steering_mode_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->steering_mode_data());
    }

    // optional .lunabotics.proto.Telecommand.DefineRoute define_route_data = 5;
    if (has_define_route_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->define_route_data());
    }

    // optional .lunabotics.proto.Telecommand.RequestMap request_map_data = 6;
    if (has_request_map_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->request_map_data());
    }

    // optional .lunabotics.proto.Telecommand.AdjustPID adjust_pid_data = 7;
    if (has_adjust_pid_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->adjust_pid_data());
    }

    // optional .lunabotics.proto.AllWheelControl all_wheel_control_data = 8;
    if (has_all_wheel_control_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->all_wheel_control_data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Telecommand::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Telecommand* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Telecommand*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Telecommand::MergeFrom(const Telecommand& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_teleoperation_data()) {
      mutable_teleoperation_data()->::lunabotics::proto::Telecommand_Teleoperation::MergeFrom(from.teleoperation_data());
    }
    if (from.has_autonomy_data()) {
      mutable_autonomy_data()->::lunabotics::proto::Telecommand_Autonomy::MergeFrom(from.autonomy_data());
    }
    if (from.has_steering_mode_data()) {
      mutable_steering_mode_data()->::lunabotics::proto::Telecommand_SteeringMode::MergeFrom(from.steering_mode_data());
    }
    if (from.has_define_route_data()) {
      mutable_define_route_data()->::lunabotics::proto::Telecommand_DefineRoute::MergeFrom(from.define_route_data());
    }
    if (from.has_request_map_data()) {
      mutable_request_map_data()->::lunabotics::proto::Telecommand_RequestMap::MergeFrom(from.request_map_data());
    }
    if (from.has_adjust_pid_data()) {
      mutable_adjust_pid_data()->::lunabotics::proto::Telecommand_AdjustPID::MergeFrom(from.adjust_pid_data());
    }
    if (from.has_all_wheel_control_data()) {
      mutable_all_wheel_control_data()->::lunabotics::proto::AllWheelControl::MergeFrom(from.all_wheel_control_data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Telecommand::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Telecommand::CopyFrom(const Telecommand& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Telecommand::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_teleoperation_data()) {
    if (!this->teleoperation_data().IsInitialized()) return false;
  }
  if (has_autonomy_data()) {
    if (!this->autonomy_data().IsInitialized()) return false;
  }
  if (has_steering_mode_data()) {
    if (!this->steering_mode_data().IsInitialized()) return false;
  }
  if (has_define_route_data()) {
    if (!this->define_route_data().IsInitialized()) return false;
  }
  if (has_adjust_pid_data()) {
    if (!this->adjust_pid_data().IsInitialized()) return false;
  }
  if (has_all_wheel_control_data()) {
    if (!this->all_wheel_control_data().IsInitialized()) return false;
  }
  return true;
}

void Telecommand::Swap(Telecommand* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(teleoperation_data_, other->teleoperation_data_);
    std::swap(autonomy_data_, other->autonomy_data_);
    std::swap(steering_mode_data_, other->steering_mode_data_);
    std::swap(define_route_data_, other->define_route_data_);
    std::swap(request_map_data_, other->request_map_data_);
    std::swap(adjust_pid_data_, other->adjust_pid_data_);
    std::swap(all_wheel_control_data_, other->all_wheel_control_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Telecommand::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Telecommand_descriptor_;
  metadata.reflection = Telecommand_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace lunabotics

// @@protoc_insertion_point(global_scope)
